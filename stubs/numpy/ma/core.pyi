from _typeshed import Incomplete
from numpy import amax as amax, amin as amin, angle as angle, bool_ as bool_, expand_dims as expand_dims, ndarray

__all__ = ['MAError', 'MaskError', 'MaskType', 'MaskedArray', 'abs', 'absolute', 'add', 'all', 'allclose', 'allequal', 'alltrue', 'amax', 'amin', 'angle', 'anom', 'anomalies', 'any', 'append', 'arange', 'arccos', 'arccosh', 'arcsin', 'arcsinh', 'arctan', 'arctan2', 'arctanh', 'argmax', 'argmin', 'argsort', 'around', 'array', 'asanyarray', 'asarray', 'bitwise_and', 'bitwise_or', 'bitwise_xor', 'bool_', 'ceil', 'choose', 'clip', 'common_fill_value', 'compress', 'compressed', 'concatenate', 'conjugate', 'convolve', 'copy', 'correlate', 'cos', 'cosh', 'count', 'cumprod', 'cumsum', 'default_fill_value', 'diag', 'diagonal', 'diff', 'divide', 'empty', 'empty_like', 'equal', 'exp', 'expand_dims', 'fabs', 'filled', 'fix_invalid', 'flatten_mask', 'flatten_structured_array', 'floor', 'floor_divide', 'fmod', 'frombuffer', 'fromflex', 'fromfunction', 'getdata', 'getmask', 'getmaskarray', 'greater', 'greater_equal', 'harden_mask', 'hypot', 'identity', 'ids', 'indices', 'inner', 'innerproduct', 'isMA', 'isMaskedArray', 'is_mask', 'is_masked', 'isarray', 'left_shift', 'less', 'less_equal', 'log', 'log10', 'log2', 'logical_and', 'logical_not', 'logical_or', 'logical_xor', 'make_mask', 'make_mask_descr', 'make_mask_none', 'mask_or', 'masked', 'masked_array', 'masked_equal', 'masked_greater', 'masked_greater_equal', 'masked_inside', 'masked_invalid', 'masked_less', 'masked_less_equal', 'masked_not_equal', 'masked_object', 'masked_outside', 'masked_print_option', 'masked_singleton', 'masked_values', 'masked_where', 'max', 'maximum', 'maximum_fill_value', 'mean', 'min', 'minimum', 'minimum_fill_value', 'mod', 'multiply', 'mvoid', 'ndim', 'negative', 'nomask', 'nonzero', 'not_equal', 'ones', 'ones_like', 'outer', 'outerproduct', 'power', 'prod', 'product', 'ptp', 'put', 'putmask', 'ravel', 'remainder', 'repeat', 'reshape', 'resize', 'right_shift', 'round', 'round_', 'set_fill_value', 'shape', 'sin', 'sinh', 'size', 'soften_mask', 'sometrue', 'sort', 'sqrt', 'squeeze', 'std', 'subtract', 'sum', 'swapaxes', 'take', 'tan', 'tanh', 'trace', 'transpose', 'true_divide', 'var', 'where', 'zeros', 'zeros_like']

MaskType: Incomplete
nomask: Incomplete

class MaskedArrayFutureWarning(FutureWarning): ...
class MAError(Exception): ...
class MaskError(MAError): ...

def default_fill_value(obj): ...
def minimum_fill_value(obj): ...
def maximum_fill_value(obj): ...
def set_fill_value(a, fill_value) -> None: ...
def common_fill_value(a, b): ...
def filled(a, fill_value: Incomplete | None = None): ...
def getdata(a, subok: bool = True): ...
get_data = getdata

def fix_invalid(a, mask=..., copy: bool = True, fill_value: Incomplete | None = None): ...

class _DomainCheckInterval:
    a: Incomplete
    b: Incomplete
    def __init__(self, a, b) -> None: ...
    def __call__(self, x): ...

class _DomainTan:
    eps: Incomplete
    def __init__(self, eps) -> None: ...
    def __call__(self, x): ...

class _DomainSafeDivide:
    tolerance: Incomplete
    def __init__(self, tolerance: Incomplete | None = None) -> None: ...
    def __call__(self, a, b): ...

class _DomainGreater:
    critical_value: Incomplete
    def __init__(self, critical_value) -> None: ...
    def __call__(self, x): ...

class _DomainGreaterEqual:
    critical_value: Incomplete
    def __init__(self, critical_value) -> None: ...
    def __call__(self, x): ...

class _MaskedUFunc:
    f: Incomplete
    __doc__: Incomplete
    __qualname__: Incomplete
    def __init__(self, ufunc) -> None: ...

class _MaskedUnaryOperation(_MaskedUFunc):
    fill: Incomplete
    domain: Incomplete
    def __init__(self, mufunc, fill: int = 0, domain: Incomplete | None = None) -> None: ...
    def __call__(self, a, *args, **kwargs): ...

class _MaskedBinaryOperation(_MaskedUFunc):
    fillx: Incomplete
    filly: Incomplete
    def __init__(self, mbfunc, fillx: int = 0, filly: int = 0) -> None: ...
    def __call__(self, a, b, *args, **kwargs): ...
    def reduce(self, target, axis: int = 0, dtype: Incomplete | None = None): ...
    def outer(self, a, b): ...
    def accumulate(self, target, axis: int = 0): ...

class _DomainedBinaryOperation(_MaskedUFunc):
    domain: Incomplete
    fillx: Incomplete
    filly: Incomplete
    def __init__(self, dbfunc, domain, fillx: int = 0, filly: int = 0) -> None: ...
    def __call__(self, a, b, *args, **kwargs): ...

exp: Incomplete
conjugate: Incomplete
sin: Incomplete
cos: Incomplete
arctan: Incomplete
arcsinh: Incomplete
sinh: Incomplete
cosh: Incomplete
tanh: Incomplete
abs: Incomplete
absolute: Incomplete
fabs: Incomplete
negative: Incomplete
floor: Incomplete
ceil: Incomplete
around: Incomplete
logical_not: Incomplete
sqrt: Incomplete
log: Incomplete
log2: Incomplete
log10: Incomplete
tan: Incomplete
arcsin: Incomplete
arccos: Incomplete
arccosh: Incomplete
arctanh: Incomplete
add: Incomplete
subtract: Incomplete
multiply: Incomplete
arctan2: Incomplete
equal: Incomplete
not_equal: Incomplete
less_equal: Incomplete
greater_equal: Incomplete
less: Incomplete
greater: Incomplete
logical_and: Incomplete
alltrue: Incomplete
logical_or: Incomplete
sometrue: Incomplete
logical_xor: Incomplete
bitwise_and: Incomplete
bitwise_or: Incomplete
bitwise_xor: Incomplete
hypot: Incomplete
divide: Incomplete
true_divide: Incomplete
floor_divide: Incomplete
remainder: Incomplete
fmod: Incomplete
mod: Incomplete

def make_mask_descr(ndtype): ...
def getmask(a): ...
get_mask = getmask

def getmaskarray(arr): ...
def is_mask(m): ...
def make_mask(m, copy: bool = False, shrink: bool = True, dtype=...): ...
def make_mask_none(newshape, dtype: Incomplete | None = None): ...
def mask_or(m1, m2, copy: bool = False, shrink: bool = True): ...
def flatten_mask(mask): ...
def masked_where(condition, a, copy: bool = True): ...
def masked_greater(x, value, copy: bool = True): ...
def masked_greater_equal(x, value, copy: bool = True): ...
def masked_less(x, value, copy: bool = True): ...
def masked_less_equal(x, value, copy: bool = True): ...
def masked_not_equal(x, value, copy: bool = True): ...
def masked_equal(x, value, copy: bool = True): ...
def masked_inside(x, v1, v2, copy: bool = True): ...
def masked_outside(x, v1, v2, copy: bool = True): ...
def masked_object(x, value, copy: bool = True, shrink: bool = True): ...
def masked_values(x, value, rtol: float = 1e-05, atol: float = 1e-08, copy: bool = True, shrink: bool = True): ...
def masked_invalid(a, copy: bool = True): ...

class _MaskedPrintOption:
    def __init__(self, display) -> None: ...
    def display(self): ...
    def set_display(self, s) -> None: ...
    def enabled(self): ...
    def enable(self, shrink: int = 1) -> None: ...

masked_print_option: Incomplete

def flatten_structured_array(a): ...

class MaskedIterator:
    ma: Incomplete
    dataiter: Incomplete
    maskiter: Incomplete
    def __init__(self, ma) -> None: ...
    def __iter__(self): ...
    def __getitem__(self, indx): ...
    def __setitem__(self, index, value) -> None: ...
    def __next__(self): ...

class MaskedArray(ndarray):
    __array_priority__: int
    def __new__(cls, data: Incomplete | None = None, mask=..., dtype: Incomplete | None = None, copy: bool = False, subok: bool = True, ndmin: int = 0, fill_value: Incomplete | None = None, keep_mask: bool = True, hard_mask: Incomplete | None = None, shrink: bool = True, order: Incomplete | None = None): ...
    def __array_finalize__(self, obj) -> None: ...
    def __array_wrap__(self, obj, context: Incomplete | None = None, return_scalar: bool = False): ...
    def view(self, dtype: Incomplete | None = None, type: Incomplete | None = None, fill_value: Incomplete | None = None): ...
    def __getitem__(self, indx): ...
    def __setitem__(self, indx, value) -> None: ...
    @property
    def dtype(self): ...
    @dtype.setter
    def dtype(self, dtype) -> None: ...
    @property
    def shape(self): ...
    @shape.setter
    def shape(self, shape) -> None: ...
    def __setmask__(self, mask, copy: bool = False) -> None: ...
    @property
    def mask(self): ...
    @mask.setter
    def mask(self, value) -> None: ...
    @property
    def recordmask(self): ...
    @recordmask.setter
    def recordmask(self, mask) -> None: ...
    def harden_mask(self): ...
    def soften_mask(self): ...
    @property
    def hardmask(self): ...
    def unshare_mask(self): ...
    @property
    def sharedmask(self): ...
    def shrink_mask(self): ...
    @property
    def baseclass(self): ...
    data: Incomplete
    @property
    def flat(self): ...
    @flat.setter
    def flat(self, value) -> None: ...
    @property
    def fill_value(self): ...
    @fill_value.setter
    def fill_value(self, value: Incomplete | None = None) -> None: ...
    get_fill_value: Incomplete
    set_fill_value: Incomplete
    def filled(self, fill_value: Incomplete | None = None): ...
    def compressed(self): ...
    def compress(self, condition, axis: Incomplete | None = None, out: Incomplete | None = None): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __le__(self, other): ...
    def __lt__(self, other): ...
    def __ge__(self, other): ...
    def __gt__(self, other): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __div__(self, other): ...
    def __truediv__(self, other): ...
    def __rtruediv__(self, other): ...
    def __floordiv__(self, other): ...
    def __rfloordiv__(self, other): ...
    def __pow__(self, other): ...
    def __rpow__(self, other): ...
    def __iadd__(self, other): ...
    def __isub__(self, other): ...
    def __imul__(self, other): ...
    def __idiv__(self, other): ...
    def __ifloordiv__(self, other): ...
    def __itruediv__(self, other): ...
    def __ipow__(self, other): ...
    def __float__(self) -> float: ...
    def __int__(self) -> int: ...
    @property
    def imag(self): ...
    get_imag: Incomplete
    @property
    def real(self): ...
    get_real: Incomplete
    def count(self, axis: Incomplete | None = None, keepdims=...): ...
    def ravel(self, order: str = 'C'): ...
    def reshape(self, *s, **kwargs): ...
    def resize(self, newshape, refcheck: bool = True, order: bool = False) -> None: ...
    def put(self, indices, values, mode: str = 'raise') -> None: ...
    def ids(self): ...
    def iscontiguous(self): ...
    def all(self, axis: Incomplete | None = None, out: Incomplete | None = None, keepdims=...): ...
    def any(self, axis: Incomplete | None = None, out: Incomplete | None = None, keepdims=...): ...
    def nonzero(self): ...
    def trace(self, offset: int = 0, axis1: int = 0, axis2: int = 1, dtype: Incomplete | None = None, out: Incomplete | None = None): ...
    def dot(self, b, out: Incomplete | None = None, strict: bool = False): ...
    def sum(self, axis: Incomplete | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None, keepdims=...): ...
    def cumsum(self, axis: Incomplete | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None): ...
    def prod(self, axis: Incomplete | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None, keepdims=...): ...
    product = prod
    def cumprod(self, axis: Incomplete | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None): ...
    def mean(self, axis: Incomplete | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None, keepdims=...): ...
    def anom(self, axis: Incomplete | None = None, dtype: Incomplete | None = None): ...
    def var(self, axis: Incomplete | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None, ddof: int = 0, keepdims=..., mean=...): ...
    def std(self, axis: Incomplete | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None, ddof: int = 0, keepdims=..., mean=...): ...
    def round(self, decimals: int = 0, out: Incomplete | None = None): ...
    def argsort(self, axis=..., kind: Incomplete | None = None, order: Incomplete | None = None, endwith: bool = True, fill_value: Incomplete | None = None, *, stable: bool = False): ...
    def argmin(self, axis: Incomplete | None = None, fill_value: Incomplete | None = None, out: Incomplete | None = None, *, keepdims=...): ...
    def argmax(self, axis: Incomplete | None = None, fill_value: Incomplete | None = None, out: Incomplete | None = None, *, keepdims=...): ...
    def sort(self, axis: int = -1, kind: Incomplete | None = None, order: Incomplete | None = None, endwith: bool = True, fill_value: Incomplete | None = None, *, stable: bool = False) -> None: ...
    def min(self, axis: Incomplete | None = None, out: Incomplete | None = None, fill_value: Incomplete | None = None, keepdims=...): ...
    def max(self, axis: Incomplete | None = None, out: Incomplete | None = None, fill_value: Incomplete | None = None, keepdims=...): ...
    def ptp(self, axis: Incomplete | None = None, out: Incomplete | None = None, fill_value: Incomplete | None = None, keepdims: bool = False): ...
    def partition(self, *args, **kwargs): ...
    def argpartition(self, *args, **kwargs): ...
    def take(self, indices, axis: Incomplete | None = None, out: Incomplete | None = None, mode: str = 'raise'): ...
    copy: Incomplete
    diagonal: Incomplete
    flatten: Incomplete
    repeat: Incomplete
    squeeze: Incomplete
    swapaxes: Incomplete
    T: Incomplete
    transpose: Incomplete
    @property
    def mT(self): ...
    def tolist(self, fill_value: Incomplete | None = None): ...
    def tostring(self, fill_value: Incomplete | None = None, order: str = 'C'): ...
    def tobytes(self, fill_value: Incomplete | None = None, order: str = 'C'): ...
    def tofile(self, fid, sep: str = '', format: str = '%s') -> None: ...
    def toflex(self): ...
    torecords = toflex
    def __reduce__(self): ...
    def __deepcopy__(self, memo: Incomplete | None = None): ...

class mvoid(MaskedArray):
    def __new__(self, data, mask=..., dtype: Incomplete | None = None, fill_value: Incomplete | None = None, hardmask: bool = False, copy: bool = False, subok: bool = True): ...
    def __getitem__(self, indx): ...
    def __setitem__(self, indx, value) -> None: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def filled(self, fill_value: Incomplete | None = None): ...
    def tolist(self): ...

def isMaskedArray(x): ...
isarray = isMaskedArray
isMA = isMaskedArray

class MaskedConstant(MaskedArray):
    def __new__(cls): ...
    __class__: Incomplete
    def __array_finalize__(self, obj): ...
    def __array_wrap__(self, obj, context: Incomplete | None = None, return_scalar: bool = False): ...
    def __format__(self, format_spec) -> str: ...
    def __reduce__(self): ...
    def __iop__(self, other): ...
    __iadd__ = __iop__
    __isub__ = __iop__
    __imul__ = __iop__
    __ifloordiv__ = __iop__
    __itruediv__ = __iop__
    __ipow__ = __iop__
    def copy(self, *args, **kwargs): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo): ...
    def __setattr__(self, attr, value): ...

masked: Incomplete

masked_singleton: Incomplete
masked_array = MaskedArray

def array(data, dtype: Incomplete | None = None, copy: bool = False, order: Incomplete | None = None, mask=..., fill_value: Incomplete | None = None, keep_mask: bool = True, hard_mask: bool = False, shrink: bool = True, subok: bool = True, ndmin: int = 0): ...
def is_masked(x): ...

class _extrema_operation(_MaskedUFunc):
    compare: Incomplete
    fill_value_func: Incomplete
    def __init__(self, ufunc, compare, fill_value) -> None: ...
    def __call__(self, a, b): ...
    def reduce(self, target, axis=...): ...
    def outer(self, a, b): ...

def min(obj, axis: Incomplete | None = None, out: Incomplete | None = None, fill_value: Incomplete | None = None, keepdims=...): ...
def max(obj, axis: Incomplete | None = None, out: Incomplete | None = None, fill_value: Incomplete | None = None, keepdims=...): ...
def ptp(obj, axis: Incomplete | None = None, out: Incomplete | None = None, fill_value: Incomplete | None = None, keepdims=...): ...

class _frommethod:
    __qualname__: Incomplete
    __doc__: Incomplete
    reversed: Incomplete
    def __init__(self, methodname, reversed: bool = False) -> None: ...
    def getdoc(self): ...
    def __call__(self, a, *args, **params): ...

all: Incomplete
anomalies: Incomplete
anom: Incomplete
any: Incomplete
compress: Incomplete
cumprod: Incomplete
cumsum: Incomplete
copy: Incomplete
diagonal: Incomplete
harden_mask: Incomplete
ids: Incomplete
maximum: Incomplete
mean: Incomplete
minimum: Incomplete
nonzero: Incomplete
prod: Incomplete
product: Incomplete
ravel: Incomplete
repeat: Incomplete
soften_mask: Incomplete
std: Incomplete
sum: Incomplete
swapaxes: Incomplete
trace: Incomplete
var: Incomplete
count: Incomplete

def take(a, indices, axis: Incomplete | None = None, out: Incomplete | None = None, mode: str = 'raise'): ...
def power(a, b, third: Incomplete | None = None): ...

argmin: Incomplete
argmax: Incomplete

def argsort(a, axis=..., kind: Incomplete | None = None, order: Incomplete | None = None, endwith: bool = True, fill_value: Incomplete | None = None, *, stable: Incomplete | None = None): ...
def sort(a, axis: int = -1, kind: Incomplete | None = None, order: Incomplete | None = None, endwith: bool = True, fill_value: Incomplete | None = None, *, stable: Incomplete | None = None): ...
def compressed(x): ...
def concatenate(arrays, axis: int = 0): ...
def diag(v, k: int = 0): ...
def left_shift(a, n): ...
def right_shift(a, n): ...
def put(a, indices, values, mode: str = 'raise'): ...
def putmask(a, mask, values) -> None: ...
def transpose(a, axes: Incomplete | None = None): ...
def reshape(a, new_shape, order: str = 'C'): ...
def resize(x, new_shape): ...
def ndim(obj): ...
def shape(obj): ...
def size(obj, axis: Incomplete | None = None): ...
def diff(a, /, n: int = 1, axis: int = -1, prepend=..., append=...): ...
def where(condition, x=..., y=...): ...
def choose(indices, choices, out: Incomplete | None = None, mode: str = 'raise'): ...
def round_(a, decimals: int = 0, out: Incomplete | None = None): ...
round = round_

def inner(a, b): ...
innerproduct = inner

def outer(a, b): ...
outerproduct = outer

def correlate(a, v, mode: str = 'valid', propagate_mask: bool = True): ...
def convolve(a, v, mode: str = 'full', propagate_mask: bool = True): ...
def allequal(a, b, fill_value: bool = True): ...
def allclose(a, b, masked_equal: bool = True, rtol: float = 1e-05, atol: float = 1e-08): ...
def asarray(a, dtype: Incomplete | None = None, order: Incomplete | None = None): ...
def asanyarray(a, dtype: Incomplete | None = None): ...
def fromflex(fxarray): ...

class _convert2ma:
    __doc__: Incomplete
    def __init__(self, funcname, np_ret, np_ma_ret, params: Incomplete | None = None) -> None: ...
    def getdoc(self, np_ret, np_ma_ret): ...
    def __call__(self, *args, **params): ...

arange: Incomplete
clip: Incomplete
empty: Incomplete
empty_like: Incomplete
frombuffer: Incomplete
fromfunction: Incomplete
identity: Incomplete
indices: Incomplete
ones: Incomplete
ones_like: Incomplete
squeeze: Incomplete
zeros: Incomplete
zeros_like: Incomplete

def append(a, b, axis: Incomplete | None = None): ...
