from .core import dot as dot
from _typeshed import Incomplete
from collections.abc import Generator
from numpy.lib._index_tricks_impl import AxisConcatenator

__all__ = ['apply_along_axis', 'apply_over_axes', 'atleast_1d', 'atleast_2d', 'atleast_3d', 'average', 'clump_masked', 'clump_unmasked', 'column_stack', 'compress_cols', 'compress_nd', 'compress_rowcols', 'compress_rows', 'count_masked', 'corrcoef', 'cov', 'diagflat', 'dot', 'dstack', 'ediff1d', 'flatnotmasked_contiguous', 'flatnotmasked_edges', 'hsplit', 'hstack', 'isin', 'in1d', 'intersect1d', 'mask_cols', 'mask_rowcols', 'mask_rows', 'masked_all', 'masked_all_like', 'median', 'mr_', 'ndenumerate', 'notmasked_contiguous', 'notmasked_edges', 'polyfit', 'row_stack', 'setdiff1d', 'setxor1d', 'stack', 'unique', 'union1d', 'vander', 'vstack']

def count_masked(arr, axis: Incomplete | None = None): ...
def masked_all(shape, dtype=...): ...
def masked_all_like(arr): ...

class _fromnxfunction:
    __qualname__: Incomplete
    __doc__: Incomplete
    def __init__(self, funcname) -> None: ...
    def getdoc(self): ...
    def __call__(self, *args, **params) -> None: ...

class _fromnxfunction_single(_fromnxfunction):
    def __call__(self, x, *args, **params): ...

class _fromnxfunction_seq(_fromnxfunction):
    def __call__(self, x, *args, **params): ...

class _fromnxfunction_args(_fromnxfunction):
    def __call__(self, *args, **params): ...

class _fromnxfunction_allargs(_fromnxfunction):
    def __call__(self, *args, **params): ...

atleast_1d: Incomplete
atleast_2d: Incomplete
atleast_3d: Incomplete
vstack: Incomplete
row_stack: Incomplete
hstack: Incomplete
column_stack: Incomplete
dstack: Incomplete
stack: Incomplete
hsplit: Incomplete
diagflat: Incomplete

def apply_along_axis(func1d, axis, arr, *args, **kwargs): ...
def apply_over_axes(func, a, axes): ...
def average(a, axis: Incomplete | None = None, weights: Incomplete | None = None, returned: bool = False, *, keepdims=...): ...
def median(a, axis: Incomplete | None = None, out: Incomplete | None = None, overwrite_input: bool = False, keepdims: bool = False): ...
def compress_nd(x, axis: Incomplete | None = None): ...
def compress_rowcols(x, axis: Incomplete | None = None): ...
def compress_rows(a): ...
def compress_cols(a): ...
def mask_rowcols(a, axis: Incomplete | None = None): ...
def mask_rows(a, axis=...): ...
def mask_cols(a, axis=...): ...
def ediff1d(arr, to_end: Incomplete | None = None, to_begin: Incomplete | None = None): ...
def unique(ar1, return_index: bool = False, return_inverse: bool = False): ...
def intersect1d(ar1, ar2, assume_unique: bool = False): ...
def setxor1d(ar1, ar2, assume_unique: bool = False): ...
def in1d(ar1, ar2, assume_unique: bool = False, invert: bool = False): ...
def isin(element, test_elements, assume_unique: bool = False, invert: bool = False): ...
def union1d(ar1, ar2): ...
def setdiff1d(ar1, ar2, assume_unique: bool = False): ...
def cov(x, y: Incomplete | None = None, rowvar: bool = True, bias: bool = False, allow_masked: bool = True, ddof: Incomplete | None = None): ...
def corrcoef(x, y: Incomplete | None = None, rowvar: bool = True, bias=..., allow_masked: bool = True, ddof=...): ...

class MAxisConcatenator(AxisConcatenator):
    concatenate: Incomplete
    @classmethod
    def makemat(cls, arr): ...
    def __getitem__(self, key): ...

class mr_class(MAxisConcatenator):
    def __init__(self) -> None: ...

mr_: Incomplete

def ndenumerate(a, compressed: bool = True) -> Generator[Incomplete]: ...
def flatnotmasked_edges(a): ...
def notmasked_edges(a, axis: Incomplete | None = None): ...
def flatnotmasked_contiguous(a): ...
def notmasked_contiguous(a, axis: Incomplete | None = None): ...
def clump_unmasked(a): ...
def clump_masked(a): ...
def vander(x, n: Incomplete | None = None): ...
def polyfit(x, y, deg, rcond: Incomplete | None = None, full: bool = False, w: Incomplete | None = None, cov: bool = False): ...
