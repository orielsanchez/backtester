from _typeshed import Incomplete
from numpy._core.multiarray import bincount as bincount

__all__ = ['select', 'piecewise', 'trim_zeros', 'copy', 'iterable', 'percentile', 'diff', 'gradient', 'angle', 'unwrap', 'sort_complex', 'flip', 'rot90', 'extract', 'place', 'vectorize', 'asarray_chkfinite', 'average', 'bincount', 'digitize', 'cov', 'corrcoef', 'median', 'sinc', 'hamming', 'hanning', 'bartlett', 'blackman', 'kaiser', 'trapezoid', 'trapz', 'i0', 'meshgrid', 'delete', 'insert', 'append', 'interp', 'quantile']

def rot90(m, k: int = 1, axes=(0, 1)): ...
def flip(m, axis: Incomplete | None = None): ...
def iterable(y): ...
def average(a, axis: Incomplete | None = None, weights: Incomplete | None = None, returned: bool = False, *, keepdims=...): ...
def asarray_chkfinite(a, dtype: Incomplete | None = None, order: Incomplete | None = None): ...
def piecewise(x, condlist, funclist, *args, **kw): ...
def select(condlist, choicelist, default: int = 0): ...
def copy(a, order: str = 'K', subok: bool = False): ...
def gradient(f, *varargs, axis: Incomplete | None = None, edge_order: int = 1): ...
def diff(a, n: int = 1, axis: int = -1, prepend=..., append=...): ...
def interp(x, xp, fp, left: Incomplete | None = None, right: Incomplete | None = None, period: Incomplete | None = None): ...
def angle(z, deg: bool = False): ...
def unwrap(p, discont: Incomplete | None = None, axis: int = -1, *, period=...): ...
def sort_complex(a): ...
def trim_zeros(filt, trim: str = 'fb', axis: Incomplete | None = None): ...
def extract(condition, arr): ...
def place(arr, mask, vals): ...

class vectorize:
    pyfunc: Incomplete
    cache: Incomplete
    signature: Incomplete
    __doc__: Incomplete
    otypes: Incomplete
    excluded: Incomplete
    def __init__(self, pyfunc=..., otypes: Incomplete | None = None, doc: Incomplete | None = None, excluded: Incomplete | None = None, cache: bool = False, signature: Incomplete | None = None) -> None: ...
    def __call__(self, *args, **kwargs): ...

def cov(m, y: Incomplete | None = None, rowvar: bool = True, bias: bool = False, ddof: Incomplete | None = None, fweights: Incomplete | None = None, aweights: Incomplete | None = None, *, dtype: Incomplete | None = None): ...
def corrcoef(x, y: Incomplete | None = None, rowvar: bool = True, bias=..., ddof=..., *, dtype: Incomplete | None = None): ...
def blackman(M): ...
def bartlett(M): ...
def hanning(M): ...
def hamming(M): ...
def i0(x): ...
def kaiser(M, beta): ...
def sinc(x): ...
def median(a, axis: Incomplete | None = None, out: Incomplete | None = None, overwrite_input: bool = False, keepdims: bool = False): ...
def percentile(a, q, axis: Incomplete | None = None, out: Incomplete | None = None, overwrite_input: bool = False, method: str = 'linear', keepdims: bool = False, *, weights: Incomplete | None = None, interpolation: Incomplete | None = None): ...
def quantile(a, q, axis: Incomplete | None = None, out: Incomplete | None = None, overwrite_input: bool = False, method: str = 'linear', keepdims: bool = False, *, weights: Incomplete | None = None, interpolation: Incomplete | None = None): ...
def trapezoid(y, x: Incomplete | None = None, dx: float = 1.0, axis: int = -1): ...
def trapz(y, x: Incomplete | None = None, dx: float = 1.0, axis: int = -1): ...
def meshgrid(*xi, copy: bool = True, sparse: bool = False, indexing: str = 'xy'): ...
def delete(arr, obj, axis: Incomplete | None = None): ...
def insert(arr, obj, values, axis: Incomplete | None = None): ...
def append(arr, values, axis: Incomplete | None = None): ...
def digitize(x, bins, right: bool = False): ...
