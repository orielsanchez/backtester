from _typeshed import Incomplete
from enum import Enum

__all__ = ['Expr']

class Language(Enum):
    Python = 0
    Fortran = 1
    C = 2

class Op(Enum):
    INTEGER = 10
    REAL = 12
    COMPLEX = 15
    STRING = 20
    ARRAY = 30
    SYMBOL = 40
    TERNARY = 100
    APPLY = 200
    INDEXING = 210
    CONCAT = 220
    RELATIONAL = 300
    TERMS = 1000
    FACTORS = 2000
    REF = 3000
    DEREF = 3001

class RelOp(Enum):
    EQ = 1
    NE = 2
    LT = 3
    LE = 4
    GT = 5
    GE = 6
    @classmethod
    def fromstring(cls, s, language=...): ...
    def tostring(self, language=...): ...

class ArithOp(Enum):
    POS = 1
    NEG = 2
    ADD = 3
    SUB = 4
    MUL = 5
    DIV = 6
    POW = 7

class OpError(Exception): ...

class Precedence(Enum):
    ATOM = 0
    POWER = 1
    UNARY = 2
    PRODUCT = 3
    SUM = 4
    LT = 6
    EQ = 7
    LAND = 11
    LOR = 12
    TERNARY = 13
    ASSIGN = 14
    TUPLE = 15
    NONE = 100

class ExprWarning(UserWarning): ...

class Expr:
    @staticmethod
    def parse(s, language=...): ...
    op: Incomplete
    data: Incomplete
    def __init__(self, op, data) -> None: ...
    def __eq__(self, other): ...
    def __hash__(self): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    def tostring(self, parent_precedence=..., language=...): ...
    def __pos__(self): ...
    def __neg__(self): ...
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    def __rmul__(self, other): ...
    def __pow__(self, other): ...
    def __truediv__(self, other): ...
    def __rtruediv__(self, other): ...
    def __floordiv__(self, other): ...
    def __rfloordiv__(self, other): ...
    def __call__(self, *args, **kwargs): ...
    def __getitem__(self, index): ...
    def substitute(self, symbols_map): ...
    def traverse(self, visit, *args, **kwargs): ...
    def contains(self, other): ...
    def symbols(self): ...
    def polynomial_atoms(self): ...
    def linear_solve(self, symbol): ...

class _Pair:
    left: Incomplete
    right: Incomplete
    def __init__(self, left, right) -> None: ...
    def substitute(self, symbols_map): ...

class _FromStringWorker:
    original: Incomplete
    quotes_map: Incomplete
    language: Incomplete
    def __init__(self, language=...) -> None: ...
    def finalize_string(self, s): ...
    def parse(self, inp): ...
    def process(self, s, context: str = 'expr'): ...
