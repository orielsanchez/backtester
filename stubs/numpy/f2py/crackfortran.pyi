from .auxfuncs import *
from . import __version__ as __version__, symbolic as symbolic
from _typeshed import Incomplete

f2py_version: Incomplete
strictf77: int
sourcecodeform: str
quiet: int
verbose: int
tabchar: Incomplete
pyffilename: str
f77modulename: str
skipemptyends: int
ignorecontains: int
dolowercase: int
debug: Incomplete
beginpattern: str
currentfilename: str
expectbegin: int
f90modulevars: Incomplete
filepositiontext: str
gotnextfile: int
groupcache: Incomplete
groupcounter: int
grouplist: Incomplete
groupname: str
include_paths: Incomplete
neededmodule: int
onlyfuncs: Incomplete
previous_context: Incomplete
skipblocksuntil: int
skipfuncs: Incomplete
skipfunctions: Incomplete
usermodules: Incomplete

def reset_global_f2py_vars() -> None: ...
def outmess(line, flag: int = 1) -> None: ...

defaultimplicitrules: Incomplete
badnames: Incomplete
invbadnames: Incomplete

def rmbadname1(name): ...
def rmbadname(names): ...
def undo_rmbadname1(name): ...
def undo_rmbadname(names): ...

COMMON_FREE_EXTENSIONS: Incomplete
COMMON_FIXED_EXTENSIONS: Incomplete

def openhook(filename, mode): ...
def is_free_format(fname): ...
def readfortrancode(ffile, dowithline=..., istop: int = 1) -> None: ...

beforethisafter: Incomplete
fortrantypes: str
typespattern: Incomplete
typespattern4implicit: Incomplete
functionpattern: Incomplete
subroutinepattern: Incomplete
groupbegins77: str
beginpattern77: Incomplete
groupbegins90: Incomplete
beginpattern90: Incomplete
groupends: str
endpattern: Incomplete
endifs: Incomplete
endifpattern: Incomplete
moduleprocedures: str
moduleprocedurepattern: Incomplete
implicitpattern: Incomplete
dimensionpattern: Incomplete
externalpattern: Incomplete
optionalpattern: Incomplete
requiredpattern: Incomplete
publicpattern: Incomplete
privatepattern: Incomplete
intrinsicpattern: Incomplete
intentpattern: Incomplete
parameterpattern: Incomplete
datapattern: Incomplete
callpattern: Incomplete
entrypattern: Incomplete
callfunpattern: Incomplete
commonpattern: Incomplete
usepattern: Incomplete
containspattern: Incomplete
formatpattern: Incomplete
f2pyenhancementspattern: Incomplete
multilinepattern: Incomplete

def split_by_unquoted(line, characters): ...

crackline_re_1: Incomplete
crackline_bind_1: Incomplete
crackline_bindlang: Incomplete

def crackline(line, reset: int = 0) -> None: ...
def markouterparen(line): ...
def markoutercomma(line, comma: str = ','): ...
def unmarkouterparen(line): ...
def appenddecl(decl, decl2, force: int = 1): ...

selectpattern: Incomplete
typedefpattern: Incomplete
nameargspattern: Incomplete
operatorpattern: Incomplete
callnameargspattern: Incomplete
real16pattern: Incomplete
real8pattern: Incomplete

def parse_name_for_bind(line): ...
def analyzeline(m, case, line) -> None: ...
def appendmultiline(group, context_name, ml) -> None: ...
def cracktypespec0(typespec, ll): ...

namepattern: Incomplete
kindselector: Incomplete
charselector: Incomplete
lenkindpattern: Incomplete
lenarraypattern: Incomplete

def removespaces(expr): ...
def markinnerspaces(line): ...
def updatevars(typespec, selector, attrspec, entitydecl): ...
def cracktypespec(typespec, selector): ...
def setattrspec(decl, attr, force: int = 0): ...
def setkindselector(decl, sel, force: int = 0): ...
def setcharselector(decl, sel, force: int = 0): ...
def getblockname(block, unknown: str = 'unknown'): ...
def setmesstext(block) -> None: ...
def get_usedict(block): ...
def get_useparameters(block, param_map: Incomplete | None = None): ...
def postcrack2(block, tab: str = '', param_map: Incomplete | None = None): ...
def postcrack(block, args: Incomplete | None = None, tab: str = ''): ...
def sortvarnames(vars): ...
def analyzecommon(block): ...
def analyzebody(block, args, tab: str = ''): ...
def buildimplicitrules(block): ...
def myeval(e, g: Incomplete | None = None, l: Incomplete | None = None): ...

getlincoef_re_1: Incomplete

def getlincoef(e, xset): ...

word_pattern: Incomplete

def get_sorted_names(vars): ...
def get_parameters(vars, global_params={}): ...
def analyzevars(block): ...

analyzeargs_re_1: Incomplete

def param_eval(v, g_params, params, dimspec: Incomplete | None = None): ...
def param_parse(d, params): ...
def expr2name(a, block, args=[]): ...
def analyzeargs(block): ...

determineexprtype_re_1: Incomplete
determineexprtype_re_2: Incomplete
determineexprtype_re_3: Incomplete
determineexprtype_re_4: Incomplete
determineexprtype_re_5: Incomplete

def determineexprtype(expr, vars, rules={}): ...
def crack2fortrangen(block, tab: str = '\n', as_interface: bool = False): ...
def common2fortran(common, tab: str = ''): ...
def use2fortran(use, tab: str = ''): ...
def true_intent_list(var): ...
def vars2fortran(block, vars, args, tab: str = '', as_interface: bool = False): ...

post_processing_hooks: Incomplete

def crackfortran(files): ...
def crack2fortran(block): ...
def traverse(obj, visit, parents=[], result: Incomplete | None = None, *args, **kwargs): ...
def character_backward_compatibility_hook(item, parents, result, *args, **kwargs): ...
