import abc
import numpy as np
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from collections.abc import Generator, Iterator, Mapping
from contextlib import ExitStack
from pandas import Index as Index, get_option as get_option
from pandas._config import using_pyarrow_string_dtype as using_pyarrow_string_dtype
from pandas._libs import lib as lib
from pandas._typing import DateTimeErrorChoices as DateTimeErrorChoices, DtypeArg as DtypeArg, DtypeBackend as DtypeBackend, IndexLabel as IndexLabel, Self as Self
from pandas.compat._optional import import_optional_dependency as import_optional_dependency
from pandas.core.api import DataFrame as DataFrame, Series as Series
from pandas.core.arrays import ArrowExtensionArray as ArrowExtensionArray
from pandas.core.base import PandasObject as PandasObject
from pandas.core.common import maybe_make_list as maybe_make_list
from pandas.core.dtypes.common import is_dict_like as is_dict_like, is_list_like as is_list_like
from pandas.core.dtypes.dtypes import ArrowDtype as ArrowDtype, DatetimeTZDtype as DatetimeTZDtype
from pandas.core.dtypes.missing import isna as isna
from pandas.core.internals.construction import convert_object_array as convert_object_array
from pandas.core.tools.datetimes import to_datetime as to_datetime
from pandas.errors import AbstractMethodError as AbstractMethodError, DatabaseError as DatabaseError
from pandas.util._exceptions import find_stack_level as find_stack_level
from pandas.util._validators import check_dtype_backend as check_dtype_backend
from sqlalchemy import Table
from sqlalchemy.sql.expression import Select as Select, TextClause as TextClause
from typing import Any, Callable, Literal, overload

def execute(sql, con, params: Incomplete | None = None): ...
@overload
def read_sql_table(table_name: str, con, schema=..., index_col: str | list[str] | None = ..., coerce_float=..., parse_dates: list[str] | dict[str, str] | None = ..., columns: list[str] | None = ..., chunksize: None = ..., dtype_backend: DtypeBackend | lib.NoDefault = ...) -> DataFrame: ...
@overload
def read_sql_table(table_name: str, con, schema=..., index_col: str | list[str] | None = ..., coerce_float=..., parse_dates: list[str] | dict[str, str] | None = ..., columns: list[str] | None = ..., chunksize: int = ..., dtype_backend: DtypeBackend | lib.NoDefault = ...) -> Iterator[DataFrame]: ...
@overload
def read_sql_query(sql, con, index_col: str | list[str] | None = ..., coerce_float=..., params: list[Any] | Mapping[str, Any] | None = ..., parse_dates: list[str] | dict[str, str] | None = ..., chunksize: None = ..., dtype: DtypeArg | None = ..., dtype_backend: DtypeBackend | lib.NoDefault = ...) -> DataFrame: ...
@overload
def read_sql_query(sql, con, index_col: str | list[str] | None = ..., coerce_float=..., params: list[Any] | Mapping[str, Any] | None = ..., parse_dates: list[str] | dict[str, str] | None = ..., chunksize: int = ..., dtype: DtypeArg | None = ..., dtype_backend: DtypeBackend | lib.NoDefault = ...) -> Iterator[DataFrame]: ...
@overload
def read_sql(sql, con, index_col: str | list[str] | None = ..., coerce_float=..., params=..., parse_dates=..., columns: list[str] = ..., chunksize: None = ..., dtype_backend: DtypeBackend | lib.NoDefault = ..., dtype: DtypeArg | None = None) -> DataFrame: ...
@overload
def read_sql(sql, con, index_col: str | list[str] | None = ..., coerce_float=..., params=..., parse_dates=..., columns: list[str] = ..., chunksize: int = ..., dtype_backend: DtypeBackend | lib.NoDefault = ..., dtype: DtypeArg | None = None) -> Iterator[DataFrame]: ...
def to_sql(frame, name: str, con, schema: str | None = None, if_exists: Literal['fail', 'replace', 'append'] = 'fail', index: bool = True, index_label: IndexLabel | None = None, chunksize: int | None = None, dtype: DtypeArg | None = None, method: Literal['multi'] | Callable | None = None, engine: str = 'auto', **engine_kwargs) -> int | None: ...
def has_table(table_name: str, con, schema: str | None = None) -> bool: ...
table_exists = has_table

def pandasSQL_builder(con, schema: str | None = None, need_transaction: bool = False) -> PandasSQL: ...

class SQLTable(PandasObject):
    name: Incomplete
    pd_sql: Incomplete
    prefix: Incomplete
    frame: Incomplete
    index: Incomplete
    schema: Incomplete
    if_exists: Incomplete
    keys: Incomplete
    dtype: Incomplete
    table: Incomplete
    def __init__(self, name: str, pandas_sql_engine, frame: Incomplete | None = None, index: bool | str | list[str] | None = True, if_exists: Literal['fail', 'replace', 'append'] = 'fail', prefix: str = 'pandas', index_label: Incomplete | None = None, schema: Incomplete | None = None, keys: Incomplete | None = None, dtype: DtypeArg | None = None) -> None: ...
    def exists(self): ...
    def sql_schema(self) -> str: ...
    def create(self) -> None: ...
    def insert_data(self) -> tuple[list[str], list[np.ndarray]]: ...
    def insert(self, chunksize: int | None = None, method: Literal['multi'] | Callable | None = None) -> int | None: ...
    def read(self, exit_stack: ExitStack, coerce_float: bool = True, parse_dates: Incomplete | None = None, columns: Incomplete | None = None, chunksize: int | None = None, dtype_backend: DtypeBackend | Literal['numpy'] = 'numpy') -> DataFrame | Iterator[DataFrame]: ...

class PandasSQL(PandasObject, ABC, metaclass=abc.ABCMeta):
    def __enter__(self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def read_table(self, table_name: str, index_col: str | list[str] | None = None, coerce_float: bool = True, parse_dates: Incomplete | None = None, columns: Incomplete | None = None, schema: str | None = None, chunksize: int | None = None, dtype_backend: DtypeBackend | Literal['numpy'] = 'numpy') -> DataFrame | Iterator[DataFrame]: ...
    @abstractmethod
    def read_query(self, sql: str, index_col: str | list[str] | None = None, coerce_float: bool = True, parse_dates: Incomplete | None = None, params: Incomplete | None = None, chunksize: int | None = None, dtype: DtypeArg | None = None, dtype_backend: DtypeBackend | Literal['numpy'] = 'numpy') -> DataFrame | Iterator[DataFrame]: ...
    @abstractmethod
    def to_sql(self, frame, name: str, if_exists: Literal['fail', 'replace', 'append'] = 'fail', index: bool = True, index_label: Incomplete | None = None, schema: Incomplete | None = None, chunksize: int | None = None, dtype: DtypeArg | None = None, method: Literal['multi'] | Callable | None = None, engine: str = 'auto', **engine_kwargs) -> int | None: ...
    @abstractmethod
    def execute(self, sql: str | Select | TextClause, params: Incomplete | None = None): ...
    @abstractmethod
    def has_table(self, name: str, schema: str | None = None) -> bool: ...

class BaseEngine:
    def insert_records(self, table: SQLTable, con, frame, name: str, index: bool | str | list[str] | None = True, schema: Incomplete | None = None, chunksize: int | None = None, method: Incomplete | None = None, **engine_kwargs) -> int | None: ...

class SQLAlchemyEngine(BaseEngine):
    def __init__(self) -> None: ...
    def insert_records(self, table: SQLTable, con, frame, name: str, index: bool | str | list[str] | None = True, schema: Incomplete | None = None, chunksize: int | None = None, method: Incomplete | None = None, **engine_kwargs) -> int | None: ...

def get_engine(engine: str) -> BaseEngine: ...

class SQLDatabase(PandasSQL):
    exit_stack: Incomplete
    con: Incomplete
    meta: Incomplete
    returns_generator: bool
    def __init__(self, con, schema: str | None = None, need_transaction: bool = False) -> None: ...
    def __exit__(self, *args) -> None: ...
    def run_transaction(self) -> Generator[Incomplete]: ...
    def execute(self, sql: str | Select | TextClause, params: Incomplete | None = None): ...
    def read_table(self, table_name: str, index_col: str | list[str] | None = None, coerce_float: bool = True, parse_dates: Incomplete | None = None, columns: Incomplete | None = None, schema: str | None = None, chunksize: int | None = None, dtype_backend: DtypeBackend | Literal['numpy'] = 'numpy') -> DataFrame | Iterator[DataFrame]: ...
    def read_query(self, sql: str, index_col: str | list[str] | None = None, coerce_float: bool = True, parse_dates: Incomplete | None = None, params: Incomplete | None = None, chunksize: int | None = None, dtype: DtypeArg | None = None, dtype_backend: DtypeBackend | Literal['numpy'] = 'numpy') -> DataFrame | Iterator[DataFrame]: ...
    read_sql = read_query
    def prep_table(self, frame, name: str, if_exists: Literal['fail', 'replace', 'append'] = 'fail', index: bool | str | list[str] | None = True, index_label: Incomplete | None = None, schema: Incomplete | None = None, dtype: DtypeArg | None = None) -> SQLTable: ...
    def check_case_sensitive(self, name: str, schema: str | None) -> None: ...
    def to_sql(self, frame, name: str, if_exists: Literal['fail', 'replace', 'append'] = 'fail', index: bool = True, index_label: Incomplete | None = None, schema: str | None = None, chunksize: int | None = None, dtype: DtypeArg | None = None, method: Literal['multi'] | Callable | None = None, engine: str = 'auto', **engine_kwargs) -> int | None: ...
    @property
    def tables(self): ...
    def has_table(self, name: str, schema: str | None = None) -> bool: ...
    def get_table(self, table_name: str, schema: str | None = None) -> Table: ...
    def drop_table(self, table_name: str, schema: str | None = None) -> None: ...

class ADBCDatabase(PandasSQL):
    con: Incomplete
    def __init__(self, con) -> None: ...
    def run_transaction(self) -> Generator[Incomplete]: ...
    def execute(self, sql: str | Select | TextClause, params: Incomplete | None = None): ...
    def read_table(self, table_name: str, index_col: str | list[str] | None = None, coerce_float: bool = True, parse_dates: Incomplete | None = None, columns: Incomplete | None = None, schema: str | None = None, chunksize: int | None = None, dtype_backend: DtypeBackend | Literal['numpy'] = 'numpy') -> DataFrame | Iterator[DataFrame]: ...
    def read_query(self, sql: str, index_col: str | list[str] | None = None, coerce_float: bool = True, parse_dates: Incomplete | None = None, params: Incomplete | None = None, chunksize: int | None = None, dtype: DtypeArg | None = None, dtype_backend: DtypeBackend | Literal['numpy'] = 'numpy') -> DataFrame | Iterator[DataFrame]: ...
    read_sql = read_query
    def to_sql(self, frame, name: str, if_exists: Literal['fail', 'replace', 'append'] = 'fail', index: bool = True, index_label: Incomplete | None = None, schema: str | None = None, chunksize: int | None = None, dtype: DtypeArg | None = None, method: Literal['multi'] | Callable | None = None, engine: str = 'auto', **engine_kwargs) -> int | None: ...
    def has_table(self, name: str, schema: str | None = None) -> bool: ...

class SQLiteTable(SQLTable):
    def __init__(self, *args, **kwargs) -> None: ...
    def sql_schema(self) -> str: ...
    def insert_statement(self, *, num_rows: int) -> str: ...

class SQLiteDatabase(PandasSQL):
    con: Incomplete
    def __init__(self, con) -> None: ...
    def run_transaction(self) -> Generator[Incomplete]: ...
    def execute(self, sql: str | Select | TextClause, params: Incomplete | None = None): ...
    def read_query(self, sql, index_col: Incomplete | None = None, coerce_float: bool = True, parse_dates: Incomplete | None = None, params: Incomplete | None = None, chunksize: int | None = None, dtype: DtypeArg | None = None, dtype_backend: DtypeBackend | Literal['numpy'] = 'numpy') -> DataFrame | Iterator[DataFrame]: ...
    def to_sql(self, frame, name: str, if_exists: str = 'fail', index: bool = True, index_label: Incomplete | None = None, schema: Incomplete | None = None, chunksize: int | None = None, dtype: DtypeArg | None = None, method: Literal['multi'] | Callable | None = None, engine: str = 'auto', **engine_kwargs) -> int | None: ...
    def has_table(self, name: str, schema: str | None = None) -> bool: ...
    def get_table(self, table_name: str, schema: str | None = None) -> None: ...
    def drop_table(self, name: str, schema: str | None = None) -> None: ...

def get_schema(frame, name: str, keys: Incomplete | None = None, con: Incomplete | None = None, dtype: DtypeArg | None = None, schema: str | None = None) -> str: ...
