import abc
import dataclasses
import tarfile
import zipfile
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from collections.abc import Hashable, Sequence
from io import BytesIO, StringIO, TextIOBase
from pandas import MultiIndex as MultiIndex
from pandas._typing import BaseBuffer as BaseBuffer, CompressionDict as CompressionDict, CompressionOptions as CompressionOptions, FilePath as FilePath, ReadBuffer as ReadBuffer, ReadCsvBuffer as ReadCsvBuffer, StorageOptions as StorageOptions, WriteBuffer as WriteBuffer
from pandas.compat import get_bz2_file as get_bz2_file, get_lzma_file as get_lzma_file
from pandas.compat._optional import import_optional_dependency as import_optional_dependency
from pandas.core.dtypes.common import is_bool as is_bool, is_file_like as is_file_like, is_integer as is_integer, is_list_like as is_list_like
from pandas.core.dtypes.generic import ABCMultiIndex as ABCMultiIndex
from pandas.util._decorators import doc as doc
from pandas.util._exceptions import find_stack_level as find_stack_level
from pathlib import Path
from types import TracebackType
from typing import AnyStr, Generic, IO, Literal, TypeVar, overload

BaseBufferT = TypeVar('BaseBufferT', bound=BaseBuffer)

@dataclasses.dataclass
class IOArgs:
    filepath_or_buffer: str | BaseBuffer
    encoding: str
    mode: str
    compression: CompressionDict
    should_close: bool = ...

@dataclasses.dataclass
class IOHandles(Generic[AnyStr]):
    handle: IO[AnyStr]
    compression: CompressionDict
    created_handles: list[IO[bytes] | IO[str]] = dataclasses.field(default_factory=list)
    is_wrapped: bool = ...
    def close(self) -> None: ...
    def __enter__(self) -> IOHandles[AnyStr]: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None) -> None: ...

def is_url(url: object) -> bool: ...
def validate_header_arg(header: object) -> None: ...
@overload
def stringify_path(filepath_or_buffer: FilePath, convert_file_like: bool = ...) -> str: ...
@overload
def stringify_path(filepath_or_buffer: BaseBufferT, convert_file_like: bool = ...) -> BaseBufferT: ...
def urlopen(*args, **kwargs): ...
def is_fsspec_url(url: FilePath | BaseBuffer) -> bool: ...
def file_path_to_url(path: str) -> str: ...

extension_to_compression: Incomplete

def get_compression_method(compression: CompressionOptions) -> tuple[str | None, CompressionDict]: ...
def infer_compression(filepath_or_buffer: FilePath | BaseBuffer, compression: str | None) -> str | None: ...
def check_parent_directory(path: Path | str) -> None: ...
@overload
def get_handle(path_or_buf: FilePath | BaseBuffer, mode: str, *, encoding: str | None = ..., compression: CompressionOptions = ..., memory_map: bool = ..., is_text: Literal[False], errors: str | None = ..., storage_options: StorageOptions = ...) -> IOHandles[bytes]: ...
@overload
def get_handle(path_or_buf: FilePath | BaseBuffer, mode: str, *, encoding: str | None = ..., compression: CompressionOptions = ..., memory_map: bool = ..., is_text: Literal[True] = ..., errors: str | None = ..., storage_options: StorageOptions = ...) -> IOHandles[str]: ...
@overload
def get_handle(path_or_buf: FilePath | BaseBuffer, mode: str, *, encoding: str | None = ..., compression: CompressionOptions = ..., memory_map: bool = ..., is_text: bool = ..., errors: str | None = ..., storage_options: StorageOptions = ...) -> IOHandles[str] | IOHandles[bytes]: ...

class _BufferedWriter(BytesIO, ABC, metaclass=abc.ABCMeta):
    buffer: Incomplete
    @abstractmethod
    def write_to_buffer(self) -> None: ...
    def close(self) -> None: ...

class _BytesTarFile(_BufferedWriter):
    archive_name: Incomplete
    name: Incomplete
    buffer: tarfile.TarFile
    def __init__(self, name: str | None = None, mode: Literal['r', 'a', 'w', 'x'] = 'r', fileobj: ReadBuffer[bytes] | WriteBuffer[bytes] | None = None, archive_name: str | None = None, **kwargs) -> None: ...
    def extend_mode(self, mode: str) -> str: ...
    def infer_filename(self) -> str | None: ...
    def write_to_buffer(self) -> None: ...

class _BytesZipFile(_BufferedWriter):
    archive_name: Incomplete
    buffer: zipfile.ZipFile
    def __init__(self, file: FilePath | ReadBuffer[bytes] | WriteBuffer[bytes], mode: str, archive_name: str | None = None, **kwargs) -> None: ...
    def infer_filename(self) -> str | None: ...
    def write_to_buffer(self) -> None: ...

class _IOWrapper:
    buffer: Incomplete
    def __init__(self, buffer: BaseBuffer) -> None: ...
    def __getattr__(self, name: str): ...
    def readable(self) -> bool: ...
    def seekable(self) -> bool: ...
    def writable(self) -> bool: ...

class _BytesIOWrapper:
    buffer: Incomplete
    encoding: Incomplete
    overflow: bytes
    def __init__(self, buffer: StringIO | TextIOBase, encoding: str = 'utf-8') -> None: ...
    def __getattr__(self, attr: str): ...
    def read(self, n: int | None = -1) -> bytes: ...

def file_exists(filepath_or_buffer: FilePath | BaseBuffer) -> bool: ...
def is_potential_multi_index(columns: Sequence[Hashable] | MultiIndex, index_col: bool | Sequence[int] | None = None) -> bool: ...
def dedup_names(names: Sequence[Hashable], is_potential_multiindex: bool) -> Sequence[Hashable]: ...
