import numpy as np
import pyarrow as pa
from _typeshed import Incomplete
from datetime import tzinfo
from pandas import Categorical as Categorical, CategoricalIndex as CategoricalIndex, DatetimeIndex as DatetimeIndex, Index as Index, IntervalIndex as IntervalIndex, PeriodIndex as PeriodIndex
from pandas._libs import lib as lib, missing as libmissing
from pandas._libs.interval import Interval as Interval
from pandas._libs.properties import cache_readonly as cache_readonly
from pandas._libs.tslibs import BaseOffset as BaseOffset, NaT as NaT, NaTType as NaTType, Period as Period, Timedelta as Timedelta, Timestamp as Timestamp, timezones as timezones, to_offset as to_offset, tz_compare as tz_compare
from pandas._libs.tslibs.dtypes import PeriodDtypeBase as PeriodDtypeBase, abbrev_to_npy_unit as abbrev_to_npy_unit
from pandas._libs.tslibs.offsets import BDay as BDay
from pandas._typing import Dtype as Dtype, DtypeObj as DtypeObj, IntervalClosedType as IntervalClosedType, Ordered as Ordered, Self as Self, npt as npt, type_t as type_t
from pandas.compat import pa_version_under10p1 as pa_version_under10p1
from pandas.core.arrays import BaseMaskedArray as BaseMaskedArray, DatetimeArray as DatetimeArray, IntervalArray as IntervalArray, NumpyExtensionArray as NumpyExtensionArray, PeriodArray as PeriodArray, SparseArray as SparseArray
from pandas.core.arrays.arrow import ArrowExtensionArray as ArrowExtensionArray
from pandas.core.dtypes.base import ExtensionDtype as ExtensionDtype, StorageExtensionDtype as StorageExtensionDtype, register_extension_dtype as register_extension_dtype
from pandas.core.dtypes.generic import ABCCategoricalIndex as ABCCategoricalIndex, ABCIndex as ABCIndex, ABCRangeIndex as ABCRangeIndex
from pandas.core.dtypes.inference import is_bool as is_bool, is_list_like as is_list_like
from pandas.errors import PerformanceWarning as PerformanceWarning
from pandas.util import capitalize_first_letter as capitalize_first_letter
from pandas.util._exceptions import find_stack_level as find_stack_level
from typing import Any

str_type = str

class PandasExtensionDtype(ExtensionDtype):
    type: Any
    kind: Any
    subdtype: Incomplete
    str: str_type
    num: int
    shape: tuple[int, ...]
    itemsize: int
    base: DtypeObj | None
    isbuiltin: int
    isnative: int
    def __hash__(self) -> int: ...
    @classmethod
    def reset_cache(cls) -> None: ...

class CategoricalDtypeType(type): ...

class CategoricalDtype(PandasExtensionDtype, ExtensionDtype):
    name: str
    type: type[CategoricalDtypeType]
    kind: str_type
    str: str
    base: Incomplete
    def __init__(self, categories: Incomplete | None = None, ordered: Ordered = False) -> None: ...
    @classmethod
    def construct_from_string(cls, string: str_type) -> CategoricalDtype: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    @classmethod
    def construct_array_type(cls) -> type_t[Categorical]: ...
    @staticmethod
    def validate_ordered(ordered: Ordered) -> None: ...
    @staticmethod
    def validate_categories(categories, fastpath: bool = False) -> Index: ...
    def update_dtype(self, dtype: str_type | CategoricalDtype) -> CategoricalDtype: ...
    @property
    def categories(self) -> Index: ...
    @property
    def ordered(self) -> Ordered: ...
    def index_class(self) -> type_t[CategoricalIndex]: ...

class DatetimeTZDtype(PandasExtensionDtype):
    type: type[Timestamp]
    kind: str_type
    num: int
    @property
    def na_value(self) -> NaTType: ...
    def base(self) -> DtypeObj: ...
    def str(self) -> str: ...
    def __init__(self, unit: str_type | DatetimeTZDtype = 'ns', tz: Incomplete | None = None) -> None: ...
    @property
    def unit(self) -> str_type: ...
    @property
    def tz(self) -> tzinfo: ...
    @classmethod
    def construct_array_type(cls) -> type_t[DatetimeArray]: ...
    @classmethod
    def construct_from_string(cls, string: str_type) -> DatetimeTZDtype: ...
    @property
    def name(self) -> str_type: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __from_arrow__(self, array: pa.Array | pa.ChunkedArray) -> DatetimeArray: ...
    def index_class(self) -> type_t[DatetimeIndex]: ...

class PeriodDtype(PeriodDtypeBase, PandasExtensionDtype):
    type: type[Period]
    kind: str_type
    str: str
    base: Incomplete
    num: int
    __hash__: Incomplete
    def __new__(cls, freq) -> PeriodDtype: ...
    def __reduce__(self) -> tuple[type_t[Self], tuple[str_type]]: ...
    @property
    def freq(self) -> BaseOffset: ...
    @classmethod
    def construct_from_string(cls, string: str_type) -> PeriodDtype: ...
    @property
    def name(self) -> str_type: ...
    @property
    def na_value(self) -> NaTType: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @classmethod
    def is_dtype(cls, dtype: object) -> bool: ...
    @classmethod
    def construct_array_type(cls) -> type_t[PeriodArray]: ...
    def __from_arrow__(self, array: pa.Array | pa.ChunkedArray) -> PeriodArray: ...
    def index_class(self) -> type_t[PeriodIndex]: ...

class IntervalDtype(PandasExtensionDtype):
    name: str
    kind: str_type
    str: str
    base: Incomplete
    num: int
    def __init__(self, subtype: Incomplete | None = None, closed: IntervalClosedType | None = None) -> None: ...
    @property
    def closed(self) -> IntervalClosedType: ...
    @property
    def subtype(self): ...
    @classmethod
    def construct_array_type(cls) -> type[IntervalArray]: ...
    @classmethod
    def construct_from_string(cls, string: str_type) -> IntervalDtype: ...
    @property
    def type(self) -> type[Interval]: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    @classmethod
    def is_dtype(cls, dtype: object) -> bool: ...
    def __from_arrow__(self, array: pa.Array | pa.ChunkedArray) -> IntervalArray: ...
    def index_class(self) -> type_t[IntervalIndex]: ...

class NumpyEADtype(ExtensionDtype):
    def __init__(self, dtype: npt.DTypeLike | NumpyEADtype | None) -> None: ...
    @property
    def numpy_dtype(self) -> np.dtype: ...
    @property
    def name(self) -> str: ...
    @property
    def type(self) -> type[np.generic]: ...
    @classmethod
    def construct_from_string(cls, string: str) -> NumpyEADtype: ...
    @classmethod
    def construct_array_type(cls) -> type_t[NumpyExtensionArray]: ...
    @property
    def kind(self) -> str: ...
    @property
    def itemsize(self) -> int: ...

class BaseMaskedDtype(ExtensionDtype):
    base: Incomplete
    type: type
    @property
    def na_value(self) -> libmissing.NAType: ...
    def numpy_dtype(self) -> np.dtype: ...
    def kind(self) -> str: ...
    def itemsize(self) -> int: ...
    @classmethod
    def construct_array_type(cls) -> type_t[BaseMaskedArray]: ...
    @classmethod
    def from_numpy_dtype(cls, dtype: np.dtype) -> BaseMaskedDtype: ...

class SparseDtype(ExtensionDtype):
    def __init__(self, dtype: Dtype = ..., fill_value: Any = None) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    @property
    def fill_value(self): ...
    @property
    def kind(self) -> str: ...
    @property
    def type(self): ...
    @property
    def subtype(self): ...
    @property
    def name(self) -> str: ...
    @classmethod
    def construct_array_type(cls) -> type_t[SparseArray]: ...
    @classmethod
    def construct_from_string(cls, string: str) -> SparseDtype: ...
    @classmethod
    def is_dtype(cls, dtype: object) -> bool: ...
    def update_dtype(self, dtype) -> SparseDtype: ...

class ArrowDtype(StorageExtensionDtype):
    pyarrow_dtype: Incomplete
    def __init__(self, pyarrow_dtype: pa.DataType) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    @property
    def type(self): ...
    @property
    def name(self) -> str: ...
    def numpy_dtype(self) -> np.dtype: ...
    def kind(self) -> str: ...
    def itemsize(self) -> int: ...
    @classmethod
    def construct_array_type(cls) -> type_t[ArrowExtensionArray]: ...
    @classmethod
    def construct_from_string(cls, string: str) -> ArrowDtype: ...
    def __from_arrow__(self, array: pa.Array | pa.ChunkedArray): ...
