import numpy as np
from collections.abc import Sequence, Sized
from pandas import Index as Index
from pandas._config import using_pyarrow_string_dtype as using_pyarrow_string_dtype
from pandas._libs import Interval as Interval, Period as Period, lib as lib
from pandas._libs.missing import NA as NA, NAType as NAType, checknull as checknull
from pandas._libs.tslibs import NaT as NaT, OutOfBoundsDatetime as OutOfBoundsDatetime, OutOfBoundsTimedelta as OutOfBoundsTimedelta, Timedelta as Timedelta, Timestamp as Timestamp, is_supported_dtype as is_supported_dtype
from pandas._libs.tslibs.timedeltas import array_to_timedelta64 as array_to_timedelta64
from pandas._typing import ArrayLike as ArrayLike, Dtype as Dtype, DtypeObj as DtypeObj, NumpyIndexT as NumpyIndexT, Scalar as Scalar, npt as npt
from pandas.core.arrays import Categorical as Categorical, DatetimeArray as DatetimeArray, ExtensionArray as ExtensionArray, IntervalArray as IntervalArray, PeriodArray as PeriodArray, TimedeltaArray as TimedeltaArray
from pandas.core.dtypes.common import ensure_int16 as ensure_int16, ensure_int32 as ensure_int32, ensure_int64 as ensure_int64, ensure_int8 as ensure_int8, ensure_object as ensure_object, ensure_str as ensure_str, is_bool as is_bool, is_complex as is_complex, is_float as is_float, is_integer as is_integer, is_object_dtype as is_object_dtype, is_scalar as is_scalar, is_string_dtype as is_string_dtype
from pandas.core.dtypes.dtypes import ArrowDtype as ArrowDtype, BaseMaskedDtype as BaseMaskedDtype, CategoricalDtype as CategoricalDtype, DatetimeTZDtype as DatetimeTZDtype, ExtensionDtype as ExtensionDtype, IntervalDtype as IntervalDtype, PandasExtensionDtype as PandasExtensionDtype, PeriodDtype as PeriodDtype
from pandas.core.dtypes.generic import ABCExtensionArray as ABCExtensionArray, ABCIndex as ABCIndex, ABCSeries as ABCSeries
from pandas.core.dtypes.inference import is_list_like as is_list_like
from pandas.core.dtypes.missing import is_valid_na_for_dtype as is_valid_na_for_dtype, isna as isna, na_value_for_dtype as na_value_for_dtype, notna as notna
from pandas.errors import IntCastingNaNError as IntCastingNaNError, LossySetitemError as LossySetitemError
from typing import Any, Literal, TypeVar, overload

NumpyArrayT = TypeVar('NumpyArrayT', bound=np.ndarray)

def maybe_convert_platform(values: list | tuple | range | np.ndarray | ExtensionArray) -> ArrayLike: ...
def is_nested_object(obj) -> bool: ...
def maybe_box_datetimelike(value: Scalar, dtype: Dtype | None = None) -> Scalar: ...
def maybe_box_native(value: Scalar | None | NAType) -> Scalar | None | NAType: ...
@overload
def maybe_downcast_to_dtype(result: np.ndarray, dtype: str | np.dtype) -> np.ndarray: ...
@overload
def maybe_downcast_to_dtype(result: ExtensionArray, dtype: str | np.dtype) -> ArrayLike: ...
@overload
def maybe_downcast_numeric(result: np.ndarray, dtype: np.dtype, do_round: bool = False) -> np.ndarray: ...
@overload
def maybe_downcast_numeric(result: ExtensionArray, dtype: DtypeObj, do_round: bool = False) -> ArrayLike: ...
def maybe_upcast_numeric_to_64bit(arr: NumpyIndexT) -> NumpyIndexT: ...
def maybe_cast_pointwise_result(result: ArrayLike, dtype: DtypeObj, numeric_only: bool = False, same_dtype: bool = True) -> ArrayLike: ...
@overload
def ensure_dtype_can_hold_na(dtype: np.dtype) -> np.dtype: ...
@overload
def ensure_dtype_can_hold_na(dtype: ExtensionDtype) -> ExtensionDtype: ...
def maybe_promote(dtype: np.dtype, fill_value=...): ...
def infer_dtype_from(val) -> tuple[DtypeObj, Any]: ...
def infer_dtype_from_scalar(val) -> tuple[DtypeObj, Any]: ...
def dict_compat(d: dict[Scalar, Scalar]) -> dict[Scalar, Scalar]: ...
def infer_dtype_from_array(arr) -> tuple[DtypeObj, ArrayLike]: ...
def invalidate_string_dtypes(dtype_set: set[DtypeObj]) -> None: ...
def coerce_indexer_dtype(indexer, categories) -> np.ndarray: ...
def convert_dtypes(input_array: ArrayLike, convert_string: bool = True, convert_integer: bool = True, convert_boolean: bool = True, convert_floating: bool = True, infer_objects: bool = False, dtype_backend: Literal['numpy_nullable', 'pyarrow'] = 'numpy_nullable') -> DtypeObj: ...
def maybe_infer_to_datetimelike(value: npt.NDArray[np.object_]) -> np.ndarray | DatetimeArray | TimedeltaArray | PeriodArray | IntervalArray: ...
def maybe_cast_to_datetime(value: np.ndarray | list, dtype: np.dtype) -> ExtensionArray | np.ndarray: ...
def find_result_type(left_dtype: DtypeObj, right: Any) -> DtypeObj: ...
def common_dtype_categorical_compat(objs: Sequence[Index | ArrayLike], dtype: DtypeObj) -> DtypeObj: ...
def np_find_common_type(*dtypes: np.dtype) -> np.dtype: ...
@overload
def find_common_type(types: list[np.dtype]) -> np.dtype: ...
@overload
def find_common_type(types: list[ExtensionDtype]) -> DtypeObj: ...
@overload
def find_common_type(types: list[DtypeObj]) -> DtypeObj: ...
def construct_2d_arraylike_from_scalar(value: Scalar, length: int, width: int, dtype: np.dtype, copy: bool) -> np.ndarray: ...
def construct_1d_arraylike_from_scalar(value: Scalar, length: int, dtype: DtypeObj | None) -> ArrayLike: ...
def construct_1d_object_array_from_listlike(values: Sized) -> np.ndarray: ...
def maybe_cast_to_integer_array(arr: list | np.ndarray, dtype: np.dtype) -> np.ndarray: ...
def can_hold_element(arr: ArrayLike, element: Any) -> bool: ...
def np_can_hold_element(dtype: np.dtype, element: Any) -> Any: ...
def np_can_cast_scalar(element: Scalar, dtype: np.dtype) -> bool: ...
