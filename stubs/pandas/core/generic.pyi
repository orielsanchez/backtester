import datetime as dt
import numpy as np
from _typeshed import Incomplete
from collections.abc import Generator, Hashable, Iterator, Mapping, Sequence
from pandas import DataFrame as DataFrame, ExcelWriter as ExcelWriter, HDFStore as HDFStore, Series as Series
from pandas._config import config as config, using_copy_on_write as using_copy_on_write, warn_copy_on_write as warn_copy_on_write
from pandas._libs import lib as lib
from pandas._libs.lib import is_range_indexer as is_range_indexer
from pandas._libs.tslibs import BaseOffset as BaseOffset, Period as Period, Tick as Tick, Timestamp as Timestamp, to_offset as to_offset
from pandas._libs.tslibs.dtypes import freq_to_period_freqstr as freq_to_period_freqstr
from pandas._typing import AlignJoin as AlignJoin, AnyArrayLike as AnyArrayLike, ArrayLike as ArrayLike, Axes as Axes, Axis as Axis, AxisInt as AxisInt, CompressionOptions as CompressionOptions, DtypeArg as DtypeArg, DtypeBackend as DtypeBackend, DtypeObj as DtypeObj, FilePath as FilePath, FillnaOptions as FillnaOptions, FloatFormatType as FloatFormatType, FormattersType as FormattersType, Frequency as Frequency, IgnoreRaise as IgnoreRaise, IndexKeyFunc as IndexKeyFunc, IndexLabel as IndexLabel, InterpolateOptions as InterpolateOptions, IntervalClosedType as IntervalClosedType, JSONSerializable as JSONSerializable, Level as Level, Manager as Manager, NDFrameT as NDFrameT, NaPosition as NaPosition, OpenFileErrors as OpenFileErrors, RandomState as RandomState, ReindexMethod as ReindexMethod, Renamer as Renamer, Scalar as Scalar, Self as Self, SequenceNotStr as SequenceNotStr, SortKind as SortKind, StorageOptions as StorageOptions, Suffixes as Suffixes, T as T, TimeAmbiguous as TimeAmbiguous, TimeNonexistent as TimeNonexistent, TimeUnit as TimeUnit, TimedeltaConvertibleTypes as TimedeltaConvertibleTypes, TimestampConvertibleTypes as TimestampConvertibleTypes, ValueKeyFunc as ValueKeyFunc, WriteBuffer as WriteBuffer, WriteExcelBuffer as WriteExcelBuffer, npt as npt
from pandas.compat import PYPY as PYPY
from pandas.compat._constants import REF_COUNT as REF_COUNT
from pandas.compat._optional import import_optional_dependency as import_optional_dependency
from pandas.core import arraylike as arraylike, common as common, indexing as indexing, missing as missing, nanops as nanops, sample as sample
from pandas.core.array_algos.replace import should_use_regex as should_use_regex
from pandas.core.arrays import ExtensionArray as ExtensionArray
from pandas.core.base import PandasObject as PandasObject
from pandas.core.construction import extract_array as extract_array
from pandas.core.dtypes.astype import astype_is_view as astype_is_view
from pandas.core.dtypes.common import ensure_object as ensure_object, ensure_platform_int as ensure_platform_int, ensure_str as ensure_str, is_bool as is_bool, is_bool_dtype as is_bool_dtype, is_dict_like as is_dict_like, is_extension_array_dtype as is_extension_array_dtype, is_list_like as is_list_like, is_number as is_number, is_numeric_dtype as is_numeric_dtype, is_re_compilable as is_re_compilable, is_scalar as is_scalar, pandas_dtype as pandas_dtype
from pandas.core.dtypes.dtypes import DatetimeTZDtype as DatetimeTZDtype, ExtensionDtype as ExtensionDtype
from pandas.core.dtypes.generic import ABCDataFrame as ABCDataFrame, ABCSeries as ABCSeries
from pandas.core.dtypes.inference import is_hashable as is_hashable, is_nested_list_like as is_nested_list_like
from pandas.core.dtypes.missing import isna as isna, notna as notna
from pandas.core.flags import Flags as Flags
from pandas.core.indexers.objects import BaseIndexer as BaseIndexer
from pandas.core.indexes.api import DatetimeIndex as DatetimeIndex, Index as Index, MultiIndex as MultiIndex, PeriodIndex as PeriodIndex, RangeIndex as RangeIndex, default_index as default_index, ensure_index as ensure_index
from pandas.core.internals import ArrayManager as ArrayManager, BlockManager as BlockManager, SingleArrayManager as SingleArrayManager
from pandas.core.internals.construction import mgr_to_mgr as mgr_to_mgr, ndarray_to_mgr as ndarray_to_mgr
from pandas.core.methods.describe import describe_ndframe as describe_ndframe
from pandas.core.missing import clean_fill_method as clean_fill_method, clean_reindex_fill_method as clean_reindex_fill_method, find_valid_index as find_valid_index
from pandas.core.resample import Resampler as Resampler
from pandas.core.reshape.concat import concat as concat
from pandas.core.sorting import get_indexer_indexer as get_indexer_indexer
from pandas.core.window import Expanding as Expanding, ExponentialMovingWindow as ExponentialMovingWindow, Rolling as Rolling, Window as Window
from pandas.errors import AbstractMethodError as AbstractMethodError, ChainedAssignmentError as ChainedAssignmentError, InvalidIndexError as InvalidIndexError, SettingWithCopyError as SettingWithCopyError, SettingWithCopyWarning as SettingWithCopyWarning
from pandas.io.formats.format import DataFrameFormatter as DataFrameFormatter, DataFrameRenderer as DataFrameRenderer
from pandas.io.formats.printing import pprint_thing as pprint_thing
from pandas.util._decorators import deprecate_nonkeyword_arguments as deprecate_nonkeyword_arguments, doc as doc
from pandas.util._exceptions import find_stack_level as find_stack_level
from pandas.util._validators import check_dtype_backend as check_dtype_backend, validate_ascending as validate_ascending, validate_bool_kwarg as validate_bool_kwarg, validate_fillna_kwargs as validate_fillna_kwargs, validate_inclusive as validate_inclusive
from typing import Any, Callable, ClassVar, Literal, NoReturn, overload

bool_t = bool

class NDFrame(PandasObject, indexing.IndexingMixin):
    def __init__(self, data: Manager) -> None: ...
    @property
    def attrs(self) -> dict[Hashable, Any]: ...
    @attrs.setter
    def attrs(self, value: Mapping[Hashable, Any]) -> None: ...
    @property
    def flags(self) -> Flags: ...
    def set_flags(self, *, copy: bool_t = False, allows_duplicate_labels: bool_t | None = None) -> Self: ...
    @property
    def shape(self) -> tuple[int, ...]: ...
    @property
    def axes(self) -> list[Index]: ...
    @property
    def ndim(self) -> int: ...
    @property
    def size(self) -> int: ...
    def set_axis(self, labels, *, axis: Axis = 0, copy: bool_t | None = None) -> Self: ...
    def swapaxes(self, axis1: Axis, axis2: Axis, copy: bool_t | None = None) -> Self: ...
    def droplevel(self, level: IndexLabel, axis: Axis = 0) -> Self: ...
    def pop(self, item: Hashable) -> Series | Any: ...
    def squeeze(self, axis: Axis | None = None): ...
    @overload
    def rename_axis(self, mapper: IndexLabel | lib.NoDefault = ..., *, index=..., columns=..., axis: Axis = ..., copy: bool_t | None = ..., inplace: Literal[False] = ...) -> Self: ...
    @overload
    def rename_axis(self, mapper: IndexLabel | lib.NoDefault = ..., *, index=..., columns=..., axis: Axis = ..., copy: bool_t | None = ..., inplace: Literal[True]) -> None: ...
    @overload
    def rename_axis(self, mapper: IndexLabel | lib.NoDefault = ..., *, index=..., columns=..., axis: Axis = ..., copy: bool_t | None = ..., inplace: bool_t = ...) -> Self | None: ...
    def equals(self, other: object) -> bool_t: ...
    def __neg__(self) -> Self: ...
    def __pos__(self) -> Self: ...
    def __invert__(self) -> Self: ...
    def __nonzero__(self) -> NoReturn: ...
    __bool__ = __nonzero__
    def bool(self) -> bool_t: ...
    def abs(self) -> Self: ...
    def __abs__(self) -> Self: ...
    def __round__(self, decimals: int = 0) -> Self: ...
    __hash__: ClassVar[None]
    def __iter__(self) -> Iterator: ...
    def keys(self) -> Index: ...
    def items(self) -> Generator[Incomplete]: ...
    def __len__(self) -> int: ...
    def __contains__(self, key) -> bool_t: ...
    @property
    def empty(self) -> bool_t: ...
    __array_priority__: int
    def __array__(self, dtype: npt.DTypeLike | None = None, copy: bool_t | None = None) -> np.ndarray: ...
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs: Any, **kwargs: Any): ...
    def to_excel(self, excel_writer: FilePath | WriteExcelBuffer | ExcelWriter, sheet_name: str = 'Sheet1', na_rep: str = '', float_format: str | None = None, columns: Sequence[Hashable] | None = None, header: Sequence[Hashable] | bool_t = True, index: bool_t = True, index_label: IndexLabel | None = None, startrow: int = 0, startcol: int = 0, engine: Literal['openpyxl', 'xlsxwriter'] | None = None, merge_cells: bool_t = True, inf_rep: str = 'inf', freeze_panes: tuple[int, int] | None = None, storage_options: StorageOptions | None = None, engine_kwargs: dict[str, Any] | None = None) -> None: ...
    def to_json(self, path_or_buf: FilePath | WriteBuffer[bytes] | WriteBuffer[str] | None = None, orient: Literal['split', 'records', 'index', 'table', 'columns', 'values'] | None = None, date_format: str | None = None, double_precision: int = 10, force_ascii: bool_t = True, date_unit: TimeUnit = 'ms', default_handler: Callable[[Any], JSONSerializable] | None = None, lines: bool_t = False, compression: CompressionOptions = 'infer', index: bool_t | None = None, indent: int | None = None, storage_options: StorageOptions | None = None, mode: Literal['a', 'w'] = 'w') -> str | None: ...
    def to_hdf(self, path_or_buf: FilePath | HDFStore, key: str, mode: Literal['a', 'w', 'r+'] = 'a', complevel: int | None = None, complib: Literal['zlib', 'lzo', 'bzip2', 'blosc'] | None = None, append: bool_t = False, format: Literal['fixed', 'table'] | None = None, index: bool_t = True, min_itemsize: int | dict[str, int] | None = None, nan_rep: Incomplete | None = None, dropna: bool_t | None = None, data_columns: Literal[True] | list[str] | None = None, errors: OpenFileErrors = 'strict', encoding: str = 'UTF-8') -> None: ...
    def to_sql(self, name: str, con, schema: str | None = None, if_exists: Literal['fail', 'replace', 'append'] = 'fail', index: bool_t = True, index_label: IndexLabel | None = None, chunksize: int | None = None, dtype: DtypeArg | None = None, method: Literal['multi'] | Callable | None = None) -> int | None: ...
    def to_pickle(self, path: FilePath | WriteBuffer[bytes], compression: CompressionOptions = 'infer', protocol: int = ..., storage_options: StorageOptions | None = None) -> None: ...
    def to_clipboard(self, excel: bool_t = True, sep: str | None = None, **kwargs) -> None: ...
    def to_xarray(self): ...
    @overload
    def to_latex(self, buf: None = ..., columns: Sequence[Hashable] | None = ..., header: bool_t | SequenceNotStr[str] = ..., index: bool_t = ..., na_rep: str = ..., formatters: FormattersType | None = ..., float_format: FloatFormatType | None = ..., sparsify: bool_t | None = ..., index_names: bool_t = ..., bold_rows: bool_t = ..., column_format: str | None = ..., longtable: bool_t | None = ..., escape: bool_t | None = ..., encoding: str | None = ..., decimal: str = ..., multicolumn: bool_t | None = ..., multicolumn_format: str | None = ..., multirow: bool_t | None = ..., caption: str | tuple[str, str] | None = ..., label: str | None = ..., position: str | None = ...) -> str: ...
    @overload
    def to_latex(self, buf: FilePath | WriteBuffer[str], columns: Sequence[Hashable] | None = ..., header: bool_t | SequenceNotStr[str] = ..., index: bool_t = ..., na_rep: str = ..., formatters: FormattersType | None = ..., float_format: FloatFormatType | None = ..., sparsify: bool_t | None = ..., index_names: bool_t = ..., bold_rows: bool_t = ..., column_format: str | None = ..., longtable: bool_t | None = ..., escape: bool_t | None = ..., encoding: str | None = ..., decimal: str = ..., multicolumn: bool_t | None = ..., multicolumn_format: str | None = ..., multirow: bool_t | None = ..., caption: str | tuple[str, str] | None = ..., label: str | None = ..., position: str | None = ...) -> None: ...
    @overload
    def to_csv(self, path_or_buf: None = ..., sep: str = ..., na_rep: str = ..., float_format: str | Callable | None = ..., columns: Sequence[Hashable] | None = ..., header: bool_t | list[str] = ..., index: bool_t = ..., index_label: IndexLabel | None = ..., mode: str = ..., encoding: str | None = ..., compression: CompressionOptions = ..., quoting: int | None = ..., quotechar: str = ..., lineterminator: str | None = ..., chunksize: int | None = ..., date_format: str | None = ..., doublequote: bool_t = ..., escapechar: str | None = ..., decimal: str = ..., errors: OpenFileErrors = ..., storage_options: StorageOptions = ...) -> str: ...
    @overload
    def to_csv(self, path_or_buf: FilePath | WriteBuffer[bytes] | WriteBuffer[str], sep: str = ..., na_rep: str = ..., float_format: str | Callable | None = ..., columns: Sequence[Hashable] | None = ..., header: bool_t | list[str] = ..., index: bool_t = ..., index_label: IndexLabel | None = ..., mode: str = ..., encoding: str | None = ..., compression: CompressionOptions = ..., quoting: int | None = ..., quotechar: str = ..., lineterminator: str | None = ..., chunksize: int | None = ..., date_format: str | None = ..., doublequote: bool_t = ..., escapechar: str | None = ..., decimal: str = ..., errors: OpenFileErrors = ..., storage_options: StorageOptions = ...) -> None: ...
    def take(self, indices, axis: Axis = 0, **kwargs) -> Self: ...
    def xs(self, key: IndexLabel, axis: Axis = 0, level: IndexLabel | None = None, drop_level: bool_t = True) -> Self: ...
    def __getitem__(self, item) -> None: ...
    def __delitem__(self, key) -> None: ...
    def get(self, key, default: Incomplete | None = None): ...
    def reindex_like(self, other, method: Literal['backfill', 'bfill', 'pad', 'ffill', 'nearest'] | None = None, copy: bool_t | None = None, limit: int | None = None, tolerance: Incomplete | None = None) -> Self: ...
    @overload
    def drop(self, labels: IndexLabel = ..., *, axis: Axis = ..., index: IndexLabel = ..., columns: IndexLabel = ..., level: Level | None = ..., inplace: Literal[True], errors: IgnoreRaise = ...) -> None: ...
    @overload
    def drop(self, labels: IndexLabel = ..., *, axis: Axis = ..., index: IndexLabel = ..., columns: IndexLabel = ..., level: Level | None = ..., inplace: Literal[False] = ..., errors: IgnoreRaise = ...) -> Self: ...
    @overload
    def drop(self, labels: IndexLabel = ..., *, axis: Axis = ..., index: IndexLabel = ..., columns: IndexLabel = ..., level: Level | None = ..., inplace: bool_t = ..., errors: IgnoreRaise = ...) -> Self | None: ...
    def add_prefix(self, prefix: str, axis: Axis | None = None) -> Self: ...
    def add_suffix(self, suffix: str, axis: Axis | None = None) -> Self: ...
    @overload
    def sort_values(self, *, axis: Axis = ..., ascending: bool_t | Sequence[bool_t] = ..., inplace: Literal[False] = ..., kind: SortKind = ..., na_position: NaPosition = ..., ignore_index: bool_t = ..., key: ValueKeyFunc = ...) -> Self: ...
    @overload
    def sort_values(self, *, axis: Axis = ..., ascending: bool_t | Sequence[bool_t] = ..., inplace: Literal[True], kind: SortKind = ..., na_position: NaPosition = ..., ignore_index: bool_t = ..., key: ValueKeyFunc = ...) -> None: ...
    @overload
    def sort_values(self, *, axis: Axis = ..., ascending: bool_t | Sequence[bool_t] = ..., inplace: bool_t = ..., kind: SortKind = ..., na_position: NaPosition = ..., ignore_index: bool_t = ..., key: ValueKeyFunc = ...) -> Self | None: ...
    @overload
    def sort_index(self, *, axis: Axis = ..., level: IndexLabel = ..., ascending: bool_t | Sequence[bool_t] = ..., inplace: Literal[True], kind: SortKind = ..., na_position: NaPosition = ..., sort_remaining: bool_t = ..., ignore_index: bool_t = ..., key: IndexKeyFunc = ...) -> None: ...
    @overload
    def sort_index(self, *, axis: Axis = ..., level: IndexLabel = ..., ascending: bool_t | Sequence[bool_t] = ..., inplace: Literal[False] = ..., kind: SortKind = ..., na_position: NaPosition = ..., sort_remaining: bool_t = ..., ignore_index: bool_t = ..., key: IndexKeyFunc = ...) -> Self: ...
    @overload
    def sort_index(self, *, axis: Axis = ..., level: IndexLabel = ..., ascending: bool_t | Sequence[bool_t] = ..., inplace: bool_t = ..., kind: SortKind = ..., na_position: NaPosition = ..., sort_remaining: bool_t = ..., ignore_index: bool_t = ..., key: IndexKeyFunc = ...) -> Self | None: ...
    def reindex(self, labels: Incomplete | None = None, *, index: Incomplete | None = None, columns: Incomplete | None = None, axis: Axis | None = None, method: ReindexMethod | None = None, copy: bool_t | None = None, level: Level | None = None, fill_value: Scalar | None = ..., limit: int | None = None, tolerance: Incomplete | None = None) -> Self: ...
    def filter(self, items: Incomplete | None = None, like: str | None = None, regex: str | None = None, axis: Axis | None = None) -> Self: ...
    def head(self, n: int = 5) -> Self: ...
    def tail(self, n: int = 5) -> Self: ...
    def sample(self, n: int | None = None, frac: float | None = None, replace: bool_t = False, weights: Incomplete | None = None, random_state: RandomState | None = None, axis: Axis | None = None, ignore_index: bool_t = False) -> Self: ...
    def pipe(self, func: Callable[..., T] | tuple[Callable[..., T], str], *args, **kwargs) -> T: ...
    def __finalize__(self, other, method: str | None = None, **kwargs) -> Self: ...
    def __getattr__(self, name: str): ...
    def __setattr__(self, name: str, value) -> None: ...
    @property
    def values(self) -> None: ...
    @property
    def dtypes(self): ...
    def astype(self, dtype, copy: bool_t | None = None, errors: IgnoreRaise = 'raise') -> Self: ...
    def copy(self, deep: bool_t | None = True) -> Self: ...
    def __copy__(self, deep: bool_t = True) -> Self: ...
    def __deepcopy__(self, memo: Incomplete | None = None) -> Self: ...
    def infer_objects(self, copy: bool_t | None = None) -> Self: ...
    def convert_dtypes(self, infer_objects: bool_t = True, convert_string: bool_t = True, convert_integer: bool_t = True, convert_boolean: bool_t = True, convert_floating: bool_t = True, dtype_backend: DtypeBackend = 'numpy_nullable') -> Self: ...
    @overload
    def fillna(self, value: Hashable | Mapping | Series | DataFrame = ..., *, method: FillnaOptions | None = ..., axis: Axis | None = ..., inplace: Literal[False] = ..., limit: int | None = ..., downcast: dict | None = ...) -> Self: ...
    @overload
    def fillna(self, value: Hashable | Mapping | Series | DataFrame = ..., *, method: FillnaOptions | None = ..., axis: Axis | None = ..., inplace: Literal[True], limit: int | None = ..., downcast: dict | None = ...) -> None: ...
    @overload
    def fillna(self, value: Hashable | Mapping | Series | DataFrame = ..., *, method: FillnaOptions | None = ..., axis: Axis | None = ..., inplace: bool_t = ..., limit: int | None = ..., downcast: dict | None = ...) -> Self | None: ...
    @overload
    def ffill(self, *, axis: None | Axis = ..., inplace: Literal[False] = ..., limit: None | int = ..., limit_area: Literal['inside', 'outside'] | None = ..., downcast: dict | None | lib.NoDefault = ...) -> Self: ...
    @overload
    def ffill(self, *, axis: None | Axis = ..., inplace: Literal[True], limit: None | int = ..., limit_area: Literal['inside', 'outside'] | None = ..., downcast: dict | None | lib.NoDefault = ...) -> None: ...
    @overload
    def ffill(self, *, axis: None | Axis = ..., inplace: bool_t = ..., limit: None | int = ..., limit_area: Literal['inside', 'outside'] | None = ..., downcast: dict | None | lib.NoDefault = ...) -> Self | None: ...
    def pad(self, *, axis: None | Axis = None, inplace: bool_t = False, limit: None | int = None, downcast: dict | None | lib.NoDefault = ...) -> Self | None: ...
    @overload
    def bfill(self, *, axis: None | Axis = ..., inplace: Literal[False] = ..., limit: None | int = ..., limit_area: Literal['inside', 'outside'] | None = ..., downcast: dict | None | lib.NoDefault = ...) -> Self: ...
    @overload
    def bfill(self, *, axis: None | Axis = ..., inplace: Literal[True], limit: None | int = ..., downcast: dict | None | lib.NoDefault = ...) -> None: ...
    @overload
    def bfill(self, *, axis: None | Axis = ..., inplace: bool_t = ..., limit: None | int = ..., limit_area: Literal['inside', 'outside'] | None = ..., downcast: dict | None | lib.NoDefault = ...) -> Self | None: ...
    def backfill(self, *, axis: None | Axis = None, inplace: bool_t = False, limit: None | int = None, downcast: dict | None | lib.NoDefault = ...) -> Self | None: ...
    @overload
    def replace(self, to_replace=..., value=..., *, inplace: Literal[False] = ..., limit: int | None = ..., regex: bool_t = ..., method: Literal['pad', 'ffill', 'bfill'] | lib.NoDefault = ...) -> Self: ...
    @overload
    def replace(self, to_replace=..., value=..., *, inplace: Literal[True], limit: int | None = ..., regex: bool_t = ..., method: Literal['pad', 'ffill', 'bfill'] | lib.NoDefault = ...) -> None: ...
    @overload
    def replace(self, to_replace=..., value=..., *, inplace: bool_t = ..., limit: int | None = ..., regex: bool_t = ..., method: Literal['pad', 'ffill', 'bfill'] | lib.NoDefault = ...) -> Self | None: ...
    @overload
    def interpolate(self, method: InterpolateOptions = ..., *, axis: Axis = ..., limit: int | None = ..., inplace: Literal[False] = ..., limit_direction: Literal['forward', 'backward', 'both'] | None = ..., limit_area: Literal['inside', 'outside'] | None = ..., downcast: Literal['infer'] | None | lib.NoDefault = ..., **kwargs) -> Self: ...
    @overload
    def interpolate(self, method: InterpolateOptions = ..., *, axis: Axis = ..., limit: int | None = ..., inplace: Literal[True], limit_direction: Literal['forward', 'backward', 'both'] | None = ..., limit_area: Literal['inside', 'outside'] | None = ..., downcast: Literal['infer'] | None | lib.NoDefault = ..., **kwargs) -> None: ...
    @overload
    def interpolate(self, method: InterpolateOptions = ..., *, axis: Axis = ..., limit: int | None = ..., inplace: bool_t = ..., limit_direction: Literal['forward', 'backward', 'both'] | None = ..., limit_area: Literal['inside', 'outside'] | None = ..., downcast: Literal['infer'] | None | lib.NoDefault = ..., **kwargs) -> Self | None: ...
    def asof(self, where, subset: Incomplete | None = None): ...
    def isna(self) -> Self: ...
    def isnull(self) -> Self: ...
    def notna(self) -> Self: ...
    def notnull(self) -> Self: ...
    @overload
    def clip(self, lower=..., upper=..., *, axis: Axis | None = ..., inplace: Literal[False] = ..., **kwargs) -> Self: ...
    @overload
    def clip(self, lower=..., upper=..., *, axis: Axis | None = ..., inplace: Literal[True], **kwargs) -> None: ...
    @overload
    def clip(self, lower=..., upper=..., *, axis: Axis | None = ..., inplace: bool_t = ..., **kwargs) -> Self | None: ...
    def asfreq(self, freq: Frequency, method: FillnaOptions | None = None, how: Literal['start', 'end'] | None = None, normalize: bool_t = False, fill_value: Hashable | None = None) -> Self: ...
    def at_time(self, time, asof: bool_t = False, axis: Axis | None = None) -> Self: ...
    def between_time(self, start_time, end_time, inclusive: IntervalClosedType = 'both', axis: Axis | None = None) -> Self: ...
    def resample(self, rule, axis: Axis | lib.NoDefault = ..., closed: Literal['right', 'left'] | None = None, label: Literal['right', 'left'] | None = None, convention: Literal['start', 'end', 's', 'e'] | lib.NoDefault = ..., kind: Literal['timestamp', 'period'] | None | lib.NoDefault = ..., on: Level | None = None, level: Level | None = None, origin: str | TimestampConvertibleTypes = 'start_day', offset: TimedeltaConvertibleTypes | None = None, group_keys: bool_t = False) -> Resampler: ...
    def first(self, offset) -> Self: ...
    def last(self, offset) -> Self: ...
    def rank(self, axis: Axis = 0, method: Literal['average', 'min', 'max', 'first', 'dense'] = 'average', numeric_only: bool_t = False, na_option: Literal['keep', 'top', 'bottom'] = 'keep', ascending: bool_t = True, pct: bool_t = False) -> Self: ...
    def compare(self, other, align_axis: Axis = 1, keep_shape: bool_t = False, keep_equal: bool_t = False, result_names: Suffixes = ('self', 'other')): ...
    def align(self, other: NDFrameT, join: AlignJoin = 'outer', axis: Axis | None = None, level: Level | None = None, copy: bool_t | None = None, fill_value: Hashable | None = None, method: FillnaOptions | None | lib.NoDefault = ..., limit: int | None | lib.NoDefault = ..., fill_axis: Axis | lib.NoDefault = ..., broadcast_axis: Axis | None | lib.NoDefault = ...) -> tuple[Self, NDFrameT]: ...
    @overload
    def where(self, cond, other=..., *, inplace: Literal[False] = ..., axis: Axis | None = ..., level: Level = ...) -> Self: ...
    @overload
    def where(self, cond, other=..., *, inplace: Literal[True], axis: Axis | None = ..., level: Level = ...) -> None: ...
    @overload
    def where(self, cond, other=..., *, inplace: bool_t = ..., axis: Axis | None = ..., level: Level = ...) -> Self | None: ...
    @overload
    def mask(self, cond, other=..., *, inplace: Literal[False] = ..., axis: Axis | None = ..., level: Level = ...) -> Self: ...
    @overload
    def mask(self, cond, other=..., *, inplace: Literal[True], axis: Axis | None = ..., level: Level = ...) -> None: ...
    @overload
    def mask(self, cond, other=..., *, inplace: bool_t = ..., axis: Axis | None = ..., level: Level = ...) -> Self | None: ...
    def shift(self, periods: int | Sequence[int] = 1, freq: Incomplete | None = None, axis: Axis = 0, fill_value: Hashable = ..., suffix: str | None = None) -> Self | DataFrame: ...
    def truncate(self, before: Incomplete | None = None, after: Incomplete | None = None, axis: Axis | None = None, copy: bool_t | None = None) -> Self: ...
    def tz_convert(self, tz, axis: Axis = 0, level: Incomplete | None = None, copy: bool_t | None = None) -> Self: ...
    def tz_localize(self, tz, axis: Axis = 0, level: Incomplete | None = None, copy: bool_t | None = None, ambiguous: TimeAmbiguous = 'raise', nonexistent: TimeNonexistent = 'raise') -> Self: ...
    def describe(self, percentiles: Incomplete | None = None, include: Incomplete | None = None, exclude: Incomplete | None = None) -> Self: ...
    def pct_change(self, periods: int = 1, fill_method: FillnaOptions | None | lib.NoDefault = ..., limit: int | None | lib.NoDefault = ..., freq: Incomplete | None = None, **kwargs) -> Self: ...
    def any(self, axis: Axis | None = 0, bool_only: bool_t = False, skipna: bool_t = True, **kwargs) -> Series | bool_t: ...
    def all(self, axis: Axis = 0, bool_only: bool_t = False, skipna: bool_t = True, **kwargs) -> Series | bool_t: ...
    def cummax(self, axis: Axis | None = None, skipna: bool_t = True, *args, **kwargs): ...
    def cummin(self, axis: Axis | None = None, skipna: bool_t = True, *args, **kwargs): ...
    def cumsum(self, axis: Axis | None = None, skipna: bool_t = True, *args, **kwargs): ...
    def cumprod(self, axis: Axis | None = None, skipna: bool_t = True, *args, **kwargs): ...
    def sem(self, axis: Axis | None = 0, skipna: bool_t = True, ddof: int = 1, numeric_only: bool_t = False, **kwargs) -> Series | float: ...
    def var(self, axis: Axis | None = 0, skipna: bool_t = True, ddof: int = 1, numeric_only: bool_t = False, **kwargs) -> Series | float: ...
    def std(self, axis: Axis | None = 0, skipna: bool_t = True, ddof: int = 1, numeric_only: bool_t = False, **kwargs) -> Series | float: ...
    def min(self, axis: Axis | None = 0, skipna: bool_t = True, numeric_only: bool_t = False, **kwargs): ...
    def max(self, axis: Axis | None = 0, skipna: bool_t = True, numeric_only: bool_t = False, **kwargs): ...
    def mean(self, axis: Axis | None = 0, skipna: bool_t = True, numeric_only: bool_t = False, **kwargs) -> Series | float: ...
    def median(self, axis: Axis | None = 0, skipna: bool_t = True, numeric_only: bool_t = False, **kwargs) -> Series | float: ...
    def skew(self, axis: Axis | None = 0, skipna: bool_t = True, numeric_only: bool_t = False, **kwargs) -> Series | float: ...
    def kurt(self, axis: Axis | None = 0, skipna: bool_t = True, numeric_only: bool_t = False, **kwargs) -> Series | float: ...
    kurtosis = kurt
    def sum(self, axis: Axis | None = 0, skipna: bool_t = True, numeric_only: bool_t = False, min_count: int = 0, **kwargs): ...
    def prod(self, axis: Axis | None = 0, skipna: bool_t = True, numeric_only: bool_t = False, min_count: int = 0, **kwargs): ...
    product = prod
    def rolling(self, window: int | dt.timedelta | str | BaseOffset | BaseIndexer, min_periods: int | None = None, center: bool_t = False, win_type: str | None = None, on: str | None = None, axis: Axis | lib.NoDefault = ..., closed: IntervalClosedType | None = None, step: int | None = None, method: str = 'single') -> Window | Rolling: ...
    def expanding(self, min_periods: int = 1, axis: Axis | lib.NoDefault = ..., method: Literal['single', 'table'] = 'single') -> Expanding: ...
    def ewm(self, com: float | None = None, span: float | None = None, halflife: float | TimedeltaConvertibleTypes | None = None, alpha: float | None = None, min_periods: int | None = 0, adjust: bool_t = True, ignore_na: bool_t = False, axis: Axis | lib.NoDefault = ..., times: np.ndarray | DataFrame | Series | None = None, method: Literal['single', 'table'] = 'single') -> ExponentialMovingWindow: ...
    def __iadd__(self, other) -> Self: ...
    def __isub__(self, other) -> Self: ...
    def __imul__(self, other) -> Self: ...
    def __itruediv__(self, other) -> Self: ...
    def __ifloordiv__(self, other) -> Self: ...
    def __imod__(self, other) -> Self: ...
    def __ipow__(self, other) -> Self: ...
    def __iand__(self, other) -> Self: ...
    def __ior__(self, other) -> Self: ...
    def __ixor__(self, other) -> Self: ...
    def first_valid_index(self) -> Hashable | None: ...
    def last_valid_index(self) -> Hashable | None: ...

def make_doc(name: str, ndim: int) -> str: ...
