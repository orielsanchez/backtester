import numpy as np
import pyarrow as pa
from _typeshed import Incomplete
from collections.abc import Sequence
from pandas import Series as Series
from pandas._libs import lib as lib
from pandas._libs.tslibs import NaT as NaT, Timedelta as Timedelta, Timestamp as Timestamp, timezones as timezones
from pandas._typing import ArrayLike as ArrayLike, AxisInt as AxisInt, Dtype as Dtype, FillnaOptions as FillnaOptions, InterpolateOptions as InterpolateOptions, Iterator as Iterator, NpDtype as NpDtype, NumpySorter as NumpySorter, NumpyValueArrayLike as NumpyValueArrayLike, PositionalIndexer as PositionalIndexer, Scalar as Scalar, Self as Self, SortKind as SortKind, TakeIndexer as TakeIndexer, TimeAmbiguous as TimeAmbiguous, TimeNonexistent as TimeNonexistent, npt as npt
from pandas.compat import pa_version_under10p1 as pa_version_under10p1, pa_version_under11p0 as pa_version_under11p0, pa_version_under13p0 as pa_version_under13p0
from pandas.core import missing as missing, ops as ops, roperator as roperator
from pandas.core.algorithms import map_array as map_array
from pandas.core.arraylike import OpsMixin as OpsMixin
from pandas.core.arrays._arrow_string_mixins import ArrowStringArrayMixin as ArrowStringArrayMixin
from pandas.core.arrays._utils import to_numpy_dtype_inference as to_numpy_dtype_inference
from pandas.core.arrays.base import ExtensionArray as ExtensionArray, ExtensionArraySupportsAnyAll as ExtensionArraySupportsAnyAll
from pandas.core.arrays.datetimes import DatetimeArray as DatetimeArray
from pandas.core.arrays.masked import BaseMaskedArray as BaseMaskedArray
from pandas.core.arrays.string_ import StringDtype as StringDtype
from pandas.core.arrays.timedeltas import TimedeltaArray as TimedeltaArray
from pandas.core.dtypes.cast import can_hold_element as can_hold_element, infer_dtype_from_scalar as infer_dtype_from_scalar
from pandas.core.dtypes.common import CategoricalDtype as CategoricalDtype, is_array_like as is_array_like, is_bool_dtype as is_bool_dtype, is_float_dtype as is_float_dtype, is_integer as is_integer, is_list_like as is_list_like, is_numeric_dtype as is_numeric_dtype, is_scalar as is_scalar
from pandas.core.dtypes.dtypes import ArrowDtype as ArrowDtype, DatetimeTZDtype as DatetimeTZDtype
from pandas.core.dtypes.missing import isna as isna
from pandas.core.indexers import check_array_indexer as check_array_indexer, unpack_tuple_and_ellipses as unpack_tuple_and_ellipses, validate_indices as validate_indices
from pandas.core.strings.base import BaseStringArrayMethods as BaseStringArrayMethods
from pandas.tseries.frequencies import to_offset as to_offset
from pandas.util._decorators import doc as doc
from pandas.util._validators import validate_fillna_kwargs as validate_fillna_kwargs
from typing import Any, Literal

ARROW_CMP_FUNCS: Incomplete
ARROW_LOGICAL_FUNCS: Incomplete
ARROW_BIT_WISE_FUNCS: Incomplete

def cast_for_truediv(arrow_array: pa.ChunkedArray, pa_object: pa.Array | pa.Scalar) -> tuple[pa.ChunkedArray, pa.Array | pa.Scalar]: ...
def floordiv_compat(left: pa.ChunkedArray | pa.Array | pa.Scalar, right: pa.ChunkedArray | pa.Array | pa.Scalar) -> pa.ChunkedArray: ...

ARROW_ARITHMETIC_FUNCS: Incomplete

def get_unit_from_pa_dtype(pa_dtype): ...
def to_pyarrow_type(dtype: ArrowDtype | pa.DataType | Dtype | None) -> pa.DataType | None: ...

class ArrowExtensionArray(OpsMixin, ExtensionArraySupportsAnyAll, ArrowStringArrayMixin, BaseStringArrayMethods):
    def __init__(self, values: pa.Array | pa.ChunkedArray) -> None: ...
    def __getitem__(self, item: PositionalIndexer): ...
    def __iter__(self) -> Iterator[Any]: ...
    def __arrow_array__(self, type: Incomplete | None = None): ...
    def __array__(self, dtype: NpDtype | None = None, copy: bool | None = None) -> np.ndarray: ...
    def __invert__(self) -> Self: ...
    def __neg__(self) -> Self: ...
    def __pos__(self) -> Self: ...
    def __abs__(self) -> Self: ...
    def equals(self, other) -> bool: ...
    @property
    def dtype(self) -> ArrowDtype: ...
    @property
    def nbytes(self) -> int: ...
    def __len__(self) -> int: ...
    def __contains__(self, key) -> bool: ...
    def isna(self) -> npt.NDArray[np.bool_]: ...
    def any(self, *, skipna: bool = True, **kwargs): ...
    def all(self, *, skipna: bool = True, **kwargs): ...
    def argsort(self, *, ascending: bool = True, kind: SortKind = 'quicksort', na_position: str = 'last', **kwargs) -> np.ndarray: ...
    def argmin(self, skipna: bool = True) -> int: ...
    def argmax(self, skipna: bool = True) -> int: ...
    def copy(self) -> Self: ...
    def dropna(self) -> Self: ...
    def fillna(self, value: object | ArrayLike | None = None, method: FillnaOptions | None = None, limit: int | None = None, copy: bool = True) -> Self: ...
    def isin(self, values: ArrayLike) -> npt.NDArray[np.bool_]: ...
    def factorize(self, use_na_sentinel: bool = True) -> tuple[np.ndarray, ExtensionArray]: ...
    def reshape(self, *args, **kwargs) -> None: ...
    def round(self, decimals: int = 0, *args, **kwargs) -> Self: ...
    def searchsorted(self, value: NumpyValueArrayLike | ExtensionArray, side: Literal['left', 'right'] = 'left', sorter: NumpySorter | None = None) -> npt.NDArray[np.intp] | np.intp: ...
    def take(self, indices: TakeIndexer, allow_fill: bool = False, fill_value: Any = None) -> ArrowExtensionArray: ...
    def to_numpy(self, dtype: npt.DTypeLike | None = None, copy: bool = False, na_value: object = ...) -> np.ndarray: ...
    def map(self, mapper, na_action: Incomplete | None = None): ...
    def duplicated(self, keep: Literal['first', 'last', False] = 'first') -> npt.NDArray[np.bool_]: ...
    def unique(self) -> Self: ...
    def value_counts(self, dropna: bool = True) -> Series: ...
    def __setitem__(self, key, value) -> None: ...
    def interpolate(self, *, method: InterpolateOptions, axis: int, index, limit, limit_direction, limit_area, copy: bool, **kwargs) -> Self: ...

def transpose_homogeneous_pyarrow(arrays: Sequence[ArrowExtensionArray]) -> list[ArrowExtensionArray]: ...
