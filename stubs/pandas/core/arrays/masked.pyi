import numpy as np
from _typeshed import Incomplete
from collections.abc import Iterator, Sequence
from pandas import Series as Series
from pandas._libs import lib as lib
from pandas._libs.tslibs import is_supported_dtype as is_supported_dtype
from pandas._typing import ArrayLike as ArrayLike, AstypeArg as AstypeArg, AxisInt as AxisInt, DtypeObj as DtypeObj, FillnaOptions as FillnaOptions, InterpolateOptions as InterpolateOptions, NpDtype as NpDtype, NumpySorter as NumpySorter, NumpyValueArrayLike as NumpyValueArrayLike, PositionalIndexer as PositionalIndexer, Scalar as Scalar, ScalarIndexer as ScalarIndexer, Self as Self, SequenceIndexer as SequenceIndexer, Shape as Shape, npt as npt
from pandas.compat import IS64 as IS64, is_platform_windows as is_platform_windows
from pandas.core import arraylike as arraylike, missing as missing, nanops as nanops, ops as ops
from pandas.core.algorithms import factorize_array as factorize_array, isin as isin, map_array as map_array, mode as mode, take as take
from pandas.core.array_algos import masked_accumulations as masked_accumulations, masked_reductions as masked_reductions
from pandas.core.array_algos.quantile import quantile_with_mask as quantile_with_mask
from pandas.core.arraylike import OpsMixin as OpsMixin
from pandas.core.arrays import BooleanArray as BooleanArray, FloatingArray as FloatingArray
from pandas.core.arrays._utils import to_numpy_dtype_inference as to_numpy_dtype_inference
from pandas.core.arrays.base import ExtensionArray as ExtensionArray
from pandas.core.construction import ensure_wrapped_if_datetimelike as ensure_wrapped_if_datetimelike, extract_array as extract_array
from pandas.core.dtypes.base import ExtensionDtype as ExtensionDtype
from pandas.core.dtypes.common import is_bool as is_bool, is_integer_dtype as is_integer_dtype, is_list_like as is_list_like, is_scalar as is_scalar, is_string_dtype as is_string_dtype, pandas_dtype as pandas_dtype
from pandas.core.dtypes.dtypes import BaseMaskedDtype as BaseMaskedDtype
from pandas.core.dtypes.missing import array_equivalent as array_equivalent, is_valid_na_for_dtype as is_valid_na_for_dtype, isna as isna, notna as notna
from pandas.core.indexers import check_array_indexer as check_array_indexer
from pandas.core.ops import invalid_comparison as invalid_comparison
from pandas.core.util.hashing import hash_array as hash_array
from pandas.errors import AbstractMethodError as AbstractMethodError
from pandas.util._decorators import doc as doc
from pandas.util._validators import validate_fillna_kwargs as validate_fillna_kwargs
from typing import Any, Literal, overload

class BaseMaskedArray(OpsMixin, ExtensionArray):
    def __init__(self, values: np.ndarray, mask: npt.NDArray[np.bool_], copy: bool = False) -> None: ...
    @property
    def dtype(self) -> BaseMaskedDtype: ...
    @overload
    def __getitem__(self, item: ScalarIndexer) -> Any: ...
    @overload
    def __getitem__(self, item: SequenceIndexer) -> Self: ...
    def fillna(self, value: Incomplete | None = None, method: Incomplete | None = None, limit: int | None = None, copy: bool = True) -> Self: ...
    def __setitem__(self, key, value) -> None: ...
    def __contains__(self, key) -> bool: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    @property
    def shape(self) -> Shape: ...
    @property
    def ndim(self) -> int: ...
    def swapaxes(self, axis1, axis2) -> Self: ...
    def delete(self, loc, axis: AxisInt = 0) -> Self: ...
    def reshape(self, *args, **kwargs) -> Self: ...
    def ravel(self, *args, **kwargs) -> Self: ...
    @property
    def T(self) -> Self: ...
    def round(self, decimals: int = 0, *args, **kwargs): ...
    def __invert__(self) -> Self: ...
    def __neg__(self) -> Self: ...
    def __pos__(self) -> Self: ...
    def __abs__(self) -> Self: ...
    def to_numpy(self, dtype: npt.DTypeLike | None = None, copy: bool = False, na_value: object = ...) -> np.ndarray: ...
    def tolist(self): ...
    @overload
    def astype(self, dtype: npt.DTypeLike, copy: bool = ...) -> np.ndarray: ...
    @overload
    def astype(self, dtype: ExtensionDtype, copy: bool = ...) -> ExtensionArray: ...
    @overload
    def astype(self, dtype: AstypeArg, copy: bool = ...) -> ArrayLike: ...
    __array_priority__: int
    def __array__(self, dtype: NpDtype | None = None, copy: bool | None = None) -> np.ndarray: ...
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs): ...
    def __arrow_array__(self, type: Incomplete | None = None): ...
    def isna(self) -> np.ndarray: ...
    @property
    def nbytes(self) -> int: ...
    def take(self, indexer, *, allow_fill: bool = False, fill_value: Scalar | None = None, axis: AxisInt = 0) -> Self: ...
    def isin(self, values: ArrayLike) -> BooleanArray: ...
    def copy(self) -> Self: ...
    def duplicated(self, keep: Literal['first', 'last', False] = 'first') -> npt.NDArray[np.bool_]: ...
    def unique(self) -> Self: ...
    def searchsorted(self, value: NumpyValueArrayLike | ExtensionArray, side: Literal['left', 'right'] = 'left', sorter: NumpySorter | None = None) -> npt.NDArray[np.intp] | np.intp: ...
    def factorize(self, use_na_sentinel: bool = True) -> tuple[np.ndarray, ExtensionArray]: ...
    def value_counts(self, dropna: bool = True) -> Series: ...
    def equals(self, other) -> bool: ...
    def sum(self, *, skipna: bool = True, min_count: int = 0, axis: AxisInt | None = 0, **kwargs): ...
    def prod(self, *, skipna: bool = True, min_count: int = 0, axis: AxisInt | None = 0, **kwargs): ...
    def mean(self, *, skipna: bool = True, axis: AxisInt | None = 0, **kwargs): ...
    def var(self, *, skipna: bool = True, axis: AxisInt | None = 0, ddof: int = 1, **kwargs): ...
    def std(self, *, skipna: bool = True, axis: AxisInt | None = 0, ddof: int = 1, **kwargs): ...
    def min(self, *, skipna: bool = True, axis: AxisInt | None = 0, **kwargs): ...
    def max(self, *, skipna: bool = True, axis: AxisInt | None = 0, **kwargs): ...
    def map(self, mapper, na_action: Incomplete | None = None): ...
    def any(self, *, skipna: bool = True, axis: AxisInt | None = 0, **kwargs): ...
    def all(self, *, skipna: bool = True, axis: AxisInt | None = 0, **kwargs): ...
    def interpolate(self, *, method: InterpolateOptions, axis: int, index, limit, limit_direction, limit_area, copy: bool, **kwargs) -> FloatingArray: ...

def transpose_homogeneous_masked_arrays(masked_arrays: Sequence[BaseMaskedArray]) -> list[BaseMaskedArray]: ...
