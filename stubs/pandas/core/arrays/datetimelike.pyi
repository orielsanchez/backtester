import numpy as np
from _typeshed import Incomplete
from collections.abc import Iterator, Sequence
from pandas import Index as Index
from pandas._libs import algos as algos, lib as lib
from pandas._libs.arrays import NDArrayBacked as NDArrayBacked
from pandas._libs.tslibs import BaseOffset as BaseOffset, IncompatibleFrequency as IncompatibleFrequency, NaT as NaT, NaTType as NaTType, Period as Period, Resolution as Resolution, Tick as Tick, Timedelta as Timedelta, Timestamp as Timestamp, add_overflowsafe as add_overflowsafe, astype_overflowsafe as astype_overflowsafe, get_unit_from_dtype as get_unit_from_dtype, iNaT as iNaT, ints_to_pydatetime as ints_to_pydatetime, ints_to_pytimedelta as ints_to_pytimedelta, periods_per_day as periods_per_day, to_offset as to_offset
from pandas._libs.tslibs.fields import RoundTo as RoundTo, round_nsint64 as round_nsint64
from pandas._libs.tslibs.np_datetime import compare_mismatched_resolutions as compare_mismatched_resolutions
from pandas._libs.tslibs.timedeltas import get_unit_for_round as get_unit_for_round
from pandas._libs.tslibs.timestamps import integer_op_not_supported as integer_op_not_supported
from pandas._typing import ArrayLike as ArrayLike, AxisInt as AxisInt, DatetimeLikeScalar as DatetimeLikeScalar, Dtype as Dtype, DtypeObj as DtypeObj, F as F, InterpolateOptions as InterpolateOptions, NpDtype as NpDtype, PositionalIndexer2D as PositionalIndexer2D, PositionalIndexerTuple as PositionalIndexerTuple, ScalarIndexer as ScalarIndexer, Self as Self, SequenceIndexer as SequenceIndexer, TimeAmbiguous as TimeAmbiguous, TimeNonexistent as TimeNonexistent, npt as npt
from pandas.core import algorithms as algorithms, missing as missing, nanops as nanops, ops as ops
from pandas.core.algorithms import isin as isin, map_array as map_array, unique1d as unique1d
from pandas.core.array_algos import datetimelike_accumulations as datetimelike_accumulations
from pandas.core.arraylike import OpsMixin as OpsMixin
from pandas.core.arrays import DatetimeArray as DatetimeArray, PeriodArray as PeriodArray, TimedeltaArray as TimedeltaArray
from pandas.core.arrays._mixins import NDArrayBackedExtensionArray as NDArrayBackedExtensionArray, ravel_compat as ravel_compat
from pandas.core.arrays.arrow.array import ArrowExtensionArray as ArrowExtensionArray
from pandas.core.arrays.base import ExtensionArray as ExtensionArray
from pandas.core.arrays.integer import IntegerArray as IntegerArray
from pandas.core.construction import ensure_wrapped_if_datetimelike as ensure_wrapped_if_datetimelike, extract_array as extract_array
from pandas.core.dtypes.cast import construct_1d_object_array_from_listlike as construct_1d_object_array_from_listlike
from pandas.core.dtypes.common import is_all_strings as is_all_strings, is_integer_dtype as is_integer_dtype, is_list_like as is_list_like, is_object_dtype as is_object_dtype, is_string_dtype as is_string_dtype, pandas_dtype as pandas_dtype
from pandas.core.dtypes.dtypes import ArrowDtype as ArrowDtype, CategoricalDtype as CategoricalDtype, DatetimeTZDtype as DatetimeTZDtype, ExtensionDtype as ExtensionDtype, PeriodDtype as PeriodDtype
from pandas.core.dtypes.generic import ABCCategorical as ABCCategorical, ABCMultiIndex as ABCMultiIndex
from pandas.core.dtypes.missing import is_valid_na_for_dtype as is_valid_na_for_dtype, isna as isna
from pandas.core.indexers import check_array_indexer as check_array_indexer, check_setitem_lengths as check_setitem_lengths
from pandas.core.ops.common import unpack_zerodim_and_defer as unpack_zerodim_and_defer
from pandas.core.ops.invalid import invalid_comparison as invalid_comparison, make_invalid_op as make_invalid_op
from pandas.errors import AbstractMethodError as AbstractMethodError, InvalidComparison as InvalidComparison, PerformanceWarning as PerformanceWarning
from pandas.tseries import frequencies as frequencies
from pandas.util._decorators import Appender as Appender, Substitution as Substitution, cache_readonly as cache_readonly
from pandas.util._exceptions import find_stack_level as find_stack_level
from typing import Any, Literal, overload

DTScalarOrNaT = DatetimeLikeScalar | NaTType

class DatetimeLikeArrayMixin(OpsMixin, NDArrayBackedExtensionArray):
    freq: BaseOffset | None
    def __init__(self, data, dtype: Dtype | None = None, freq: Incomplete | None = None, copy: bool = False) -> None: ...
    def __iter__(self) -> Iterator: ...
    @property
    def asi8(self) -> npt.NDArray[np.int64]: ...
    def __array__(self, dtype: NpDtype | None = None, copy: bool | None = None) -> np.ndarray: ...
    @overload
    def __getitem__(self, item: ScalarIndexer) -> DTScalarOrNaT: ...
    @overload
    def __getitem__(self, item: SequenceIndexer | PositionalIndexerTuple) -> Self: ...
    def __setitem__(self, key: int | Sequence[int] | Sequence[bool] | slice, value: NaTType | Any | Sequence[Any]) -> None: ...
    def astype(self, dtype, copy: bool = True): ...
    @overload
    def view(self) -> Self: ...
    @overload
    def view(self, dtype: Literal['M8[ns]']) -> DatetimeArray: ...
    @overload
    def view(self, dtype: Literal['m8[ns]']) -> TimedeltaArray: ...
    @overload
    def view(self, dtype: Dtype | None = ...) -> ArrayLike: ...
    def map(self, mapper, na_action: Incomplete | None = None): ...
    def isin(self, values: ArrayLike) -> npt.NDArray[np.bool_]: ...
    def isna(self) -> npt.NDArray[np.bool_]: ...
    @property
    def freqstr(self) -> str | None: ...
    @property
    def inferred_freq(self) -> str | None: ...
    @property
    def resolution(self) -> str: ...
    __pow__: Incomplete
    __rpow__: Incomplete
    __mul__: Incomplete
    __rmul__: Incomplete
    __truediv__: Incomplete
    __rtruediv__: Incomplete
    __floordiv__: Incomplete
    __rfloordiv__: Incomplete
    __mod__: Incomplete
    __rmod__: Incomplete
    __divmod__: Incomplete
    __rdivmod__: Incomplete
    def __add__(self, other): ...
    def __radd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __iadd__(self, other) -> Self: ...
    def __isub__(self, other) -> Self: ...
    def min(self, *, axis: AxisInt | None = None, skipna: bool = True, **kwargs): ...
    def max(self, *, axis: AxisInt | None = None, skipna: bool = True, **kwargs): ...
    def mean(self, *, skipna: bool = True, axis: AxisInt | None = 0): ...
    def median(self, *, axis: AxisInt | None = None, skipna: bool = True, **kwargs): ...

class DatelikeOps(DatetimeLikeArrayMixin):
    def strftime(self, date_format: str) -> npt.NDArray[np.object_]: ...

class TimelikeOps(DatetimeLikeArrayMixin):
    def __init__(self, values, dtype: Incomplete | None = None, freq=..., copy: bool = False) -> None: ...
    @property
    def freq(self): ...
    @freq.setter
    def freq(self, value) -> None: ...
    def unit(self) -> str: ...
    def as_unit(self, unit: str, round_ok: bool = True) -> Self: ...
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs): ...
    def round(self, freq, ambiguous: TimeAmbiguous = 'raise', nonexistent: TimeNonexistent = 'raise') -> Self: ...
    def floor(self, freq, ambiguous: TimeAmbiguous = 'raise', nonexistent: TimeNonexistent = 'raise') -> Self: ...
    def ceil(self, freq, ambiguous: TimeAmbiguous = 'raise', nonexistent: TimeNonexistent = 'raise') -> Self: ...
    def any(self, *, axis: AxisInt | None = None, skipna: bool = True) -> bool: ...
    def all(self, *, axis: AxisInt | None = None, skipna: bool = True) -> bool: ...
    def factorize(self, use_na_sentinel: bool = True, sort: bool = False): ...
    def copy(self, order: str = 'C') -> Self: ...
    def interpolate(self, *, method: InterpolateOptions, axis: int, index: Index, limit, limit_direction, limit_area, copy: bool, **kwargs) -> Self: ...

def ensure_arraylike_for_datetimelike(data, copy: bool, cls_name: str) -> tuple[ArrayLike, bool]: ...
@overload
def validate_periods(periods: None) -> None: ...
@overload
def validate_periods(periods: int | float) -> int: ...
def dtype_to_unit(dtype: DatetimeTZDtype | np.dtype | ArrowDtype) -> str: ...
