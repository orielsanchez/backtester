import numpy as np
import pyarrow
from _typeshed import Incomplete
from pandas import Series as Series
from pandas._config import get_option as get_option
from pandas._libs import lib as lib, missing as libmissing
from pandas._libs.arrays import NDArrayBacked as NDArrayBacked
from pandas._libs.lib import ensure_string_array as ensure_string_array
from pandas._typing import AxisInt as AxisInt, Dtype as Dtype, DtypeObj as DtypeObj, NumpySorter as NumpySorter, NumpyValueArrayLike as NumpyValueArrayLike, Scalar as Scalar, Self as Self, npt as npt, type_t as type_t
from pandas.compat import pa_version_under10p1 as pa_version_under10p1
from pandas.core import ops as ops
from pandas.core.array_algos import masked_reductions as masked_reductions
from pandas.core.arrays.base import ExtensionArray as ExtensionArray
from pandas.core.arrays.floating import FloatingArray as FloatingArray, FloatingDtype as FloatingDtype
from pandas.core.arrays.integer import IntegerArray as IntegerArray, IntegerDtype as IntegerDtype
from pandas.core.arrays.numpy_ import NumpyExtensionArray as NumpyExtensionArray
from pandas.core.construction import extract_array as extract_array
from pandas.core.dtypes.base import ExtensionDtype as ExtensionDtype, StorageExtensionDtype as StorageExtensionDtype, register_extension_dtype as register_extension_dtype
from pandas.core.dtypes.common import is_array_like as is_array_like, is_bool_dtype as is_bool_dtype, is_integer_dtype as is_integer_dtype, is_object_dtype as is_object_dtype, is_string_dtype as is_string_dtype, pandas_dtype as pandas_dtype
from pandas.core.indexers import check_array_indexer as check_array_indexer
from pandas.core.missing import isna as isna
from pandas.util._decorators import doc as doc
from typing import ClassVar, Literal

class StringDtype(StorageExtensionDtype):
    name: ClassVar[str]
    @property
    def na_value(self) -> libmissing.NAType | float: ...
    storage: Incomplete
    def __init__(self, storage: Incomplete | None = None) -> None: ...
    @property
    def type(self) -> type[str]: ...
    @classmethod
    def construct_from_string(cls, string) -> Self: ...
    def construct_array_type(self) -> type_t[BaseStringArray]: ...
    def __from_arrow__(self, array: pyarrow.Array | pyarrow.ChunkedArray) -> BaseStringArray: ...

class BaseStringArray(ExtensionArray):
    def tolist(self): ...

class StringArray(BaseStringArray, NumpyExtensionArray):
    def __init__(self, values, copy: bool = False) -> None: ...
    def __arrow_array__(self, type: Incomplete | None = None): ...
    def __setitem__(self, key, value) -> None: ...
    def astype(self, dtype, copy: bool = True): ...
    def min(self, axis: Incomplete | None = None, skipna: bool = True, **kwargs) -> Scalar: ...
    def max(self, axis: Incomplete | None = None, skipna: bool = True, **kwargs) -> Scalar: ...
    def value_counts(self, dropna: bool = True) -> Series: ...
    def memory_usage(self, deep: bool = False) -> int: ...
    def searchsorted(self, value: NumpyValueArrayLike | ExtensionArray, side: Literal['left', 'right'] = 'left', sorter: NumpySorter | None = None) -> npt.NDArray[np.intp] | np.intp: ...
