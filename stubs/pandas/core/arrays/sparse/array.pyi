import numpy as np
from _typeshed import Incomplete
from enum import Enum
from pandas import Series as Series
from pandas._libs import lib as lib
from pandas._libs.sparse import BlockIndex as BlockIndex, IntIndex as IntIndex, SparseIndex as SparseIndex
from pandas._libs.tslibs import NaT as NaT
from pandas._typing import ArrayLike as ArrayLike, AstypeArg as AstypeArg, Axis as Axis, AxisInt as AxisInt, Dtype as Dtype, FillnaOptions as FillnaOptions, NpDtype as NpDtype, NumpySorter as NumpySorter, PositionalIndexer as PositionalIndexer, Scalar as Scalar, ScalarIndexer as ScalarIndexer, Self as Self, SequenceIndexer as SequenceIndexer, npt as npt
from pandas.core import arraylike as arraylike
from pandas.core.arraylike import OpsMixin as OpsMixin
from pandas.core.arrays import ExtensionArray as ExtensionArray
from pandas.core.base import PandasObject as PandasObject
from pandas.core.construction import ensure_wrapped_if_datetimelike as ensure_wrapped_if_datetimelike, extract_array as extract_array, sanitize_array as sanitize_array
from pandas.core.dtypes.astype import astype_array as astype_array
from pandas.core.dtypes.cast import construct_1d_arraylike_from_scalar as construct_1d_arraylike_from_scalar, find_common_type as find_common_type, maybe_box_datetimelike as maybe_box_datetimelike
from pandas.core.dtypes.common import is_bool_dtype as is_bool_dtype, is_integer as is_integer, is_list_like as is_list_like, is_object_dtype as is_object_dtype, is_scalar as is_scalar, is_string_dtype as is_string_dtype, pandas_dtype as pandas_dtype
from pandas.core.dtypes.dtypes import DatetimeTZDtype as DatetimeTZDtype, SparseDtype as SparseDtype
from pandas.core.dtypes.generic import ABCIndex as ABCIndex, ABCSeries as ABCSeries
from pandas.core.dtypes.missing import isna as isna, na_value_for_dtype as na_value_for_dtype, notna as notna
from pandas.core.indexers import check_array_indexer as check_array_indexer, unpack_tuple_and_ellipses as unpack_tuple_and_ellipses
from pandas.core.nanops import check_below_min_count as check_below_min_count
from pandas.errors import PerformanceWarning as PerformanceWarning
from pandas.io.formats import printing as printing
from pandas.util._decorators import doc as doc
from pandas.util._exceptions import find_stack_level as find_stack_level
from pandas.util._validators import validate_bool_kwarg as validate_bool_kwarg, validate_insert_loc as validate_insert_loc
from scipy.sparse import spmatrix as spmatrix
from typing import Any, Literal, overload

class ellipsis(Enum):
    Ellipsis = '...'

Ellipsis: Incomplete
SparseIndexKind: Incomplete

class SparseArray(OpsMixin, PandasObject, ExtensionArray):
    def __init__(self, data, sparse_index: Incomplete | None = None, fill_value: Incomplete | None = None, kind: SparseIndexKind = 'integer', dtype: Dtype | None = None, copy: bool = False) -> None: ...
    @classmethod
    def from_spmatrix(cls, data: spmatrix) -> Self: ...
    def __array__(self, dtype: NpDtype | None = None, copy: bool | None = None) -> np.ndarray: ...
    def __setitem__(self, key, value) -> None: ...
    @property
    def sp_index(self) -> SparseIndex: ...
    @property
    def sp_values(self) -> np.ndarray: ...
    @property
    def dtype(self) -> SparseDtype: ...
    @property
    def fill_value(self): ...
    @fill_value.setter
    def fill_value(self, value) -> None: ...
    @property
    def kind(self) -> SparseIndexKind: ...
    def __len__(self) -> int: ...
    @property
    def nbytes(self) -> int: ...
    @property
    def density(self) -> float: ...
    @property
    def npoints(self) -> int: ...
    def isna(self) -> Self: ...
    def fillna(self, value: Incomplete | None = None, method: FillnaOptions | None = None, limit: int | None = None, copy: bool = True) -> Self: ...
    def shift(self, periods: int = 1, fill_value: Incomplete | None = None) -> Self: ...
    def duplicated(self, keep: Literal['first', 'last', False] = 'first') -> npt.NDArray[np.bool_]: ...
    def unique(self) -> Self: ...
    def factorize(self, use_na_sentinel: bool = True) -> tuple[np.ndarray, SparseArray]: ...
    def value_counts(self, dropna: bool = True) -> Series: ...
    @overload
    def __getitem__(self, key: ScalarIndexer) -> Any: ...
    @overload
    def __getitem__(self, key: SequenceIndexer | tuple[int | ellipsis, ...]) -> Self: ...
    def take(self, indices, *, allow_fill: bool = False, fill_value: Incomplete | None = None) -> Self: ...
    def searchsorted(self, v: ArrayLike | object, side: Literal['left', 'right'] = 'left', sorter: NumpySorter | None = None) -> npt.NDArray[np.intp] | np.intp: ...
    def copy(self) -> Self: ...
    def astype(self, dtype: AstypeArg | None = None, copy: bool = True): ...
    def map(self, mapper, na_action: Incomplete | None = None) -> Self: ...
    def to_dense(self) -> np.ndarray: ...
    def nonzero(self) -> tuple[npt.NDArray[np.int32]]: ...
    def all(self, axis: Incomplete | None = None, *args, **kwargs): ...
    def any(self, axis: AxisInt = 0, *args, **kwargs) -> bool: ...
    def sum(self, axis: AxisInt = 0, min_count: int = 0, skipna: bool = True, *args, **kwargs) -> Scalar: ...
    def cumsum(self, axis: AxisInt = 0, *args, **kwargs) -> SparseArray: ...
    def mean(self, axis: Axis = 0, *args, **kwargs): ...
    def max(self, *, axis: AxisInt | None = None, skipna: bool = True): ...
    def min(self, *, axis: AxisInt | None = None, skipna: bool = True): ...
    def argmax(self, skipna: bool = True) -> int: ...
    def argmin(self, skipna: bool = True) -> int: ...
    def __array_ufunc__(self, ufunc: np.ufunc, method: str, *inputs, **kwargs): ...
    def __pos__(self) -> SparseArray: ...
    def __neg__(self) -> SparseArray: ...
    def __invert__(self) -> SparseArray: ...
    def __abs__(self) -> SparseArray: ...

@overload
def make_sparse_index(length: int, indices, kind: Literal['block']) -> BlockIndex: ...
@overload
def make_sparse_index(length: int, indices, kind: Literal['integer']) -> IntIndex: ...
