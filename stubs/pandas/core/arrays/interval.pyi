import numpy as np
from _typeshed import Incomplete
from collections.abc import Iterator, Sequence
from pandas import Index as Index, Series as Series
from pandas._libs import lib as lib
from pandas._libs.interval import Interval as Interval, IntervalMixin as IntervalMixin, VALID_CLOSED as VALID_CLOSED, intervals_to_interval_bounds as intervals_to_interval_bounds
from pandas._libs.missing import NA as NA
from pandas._typing import ArrayLike as ArrayLike, AxisInt as AxisInt, Dtype as Dtype, FillnaOptions as FillnaOptions, IntervalClosedType as IntervalClosedType, NpDtype as NpDtype, PositionalIndexer as PositionalIndexer, ScalarIndexer as ScalarIndexer, Self as Self, SequenceIndexer as SequenceIndexer, SortKind as SortKind, TimeArrayLike as TimeArrayLike, npt as npt
from pandas.core.algorithms import isin as isin, take as take, unique as unique
from pandas.core.arrays import ArrowExtensionArray as ArrowExtensionArray
from pandas.core.arrays.base import ExtensionArray as ExtensionArray
from pandas.core.arrays.datetimes import DatetimeArray as DatetimeArray
from pandas.core.arrays.timedeltas import TimedeltaArray as TimedeltaArray
from pandas.core.construction import ensure_wrapped_if_datetimelike as ensure_wrapped_if_datetimelike, extract_array as extract_array
from pandas.core.dtypes.cast import LossySetitemError as LossySetitemError, maybe_upcast_numeric_to_64bit as maybe_upcast_numeric_to_64bit
from pandas.core.dtypes.common import is_float_dtype as is_float_dtype, is_integer_dtype as is_integer_dtype, is_list_like as is_list_like, is_object_dtype as is_object_dtype, is_scalar as is_scalar, is_string_dtype as is_string_dtype, needs_i8_conversion as needs_i8_conversion, pandas_dtype as pandas_dtype
from pandas.core.dtypes.dtypes import CategoricalDtype as CategoricalDtype, IntervalDtype as IntervalDtype
from pandas.core.dtypes.generic import ABCDataFrame as ABCDataFrame, ABCDatetimeIndex as ABCDatetimeIndex, ABCIntervalIndex as ABCIntervalIndex, ABCPeriodIndex as ABCPeriodIndex
from pandas.core.dtypes.missing import is_valid_na_for_dtype as is_valid_na_for_dtype, isna as isna, notna as notna
from pandas.core.indexers import check_array_indexer as check_array_indexer
from pandas.core.ops import invalid_comparison as invalid_comparison, unpack_zerodim_and_defer as unpack_zerodim_and_defer
from pandas.errors import IntCastingNaNError as IntCastingNaNError
from pandas.util._decorators import Appender as Appender
from typing import Literal, overload

IntervalSide = TimeArrayLike | np.ndarray
IntervalOrNA = Interval | float

class IntervalArray(IntervalMixin, ExtensionArray):
    can_hold_na: bool
    @property
    def ndim(self) -> Literal[1]: ...
    def __new__(cls, data, closed: IntervalClosedType | None = None, dtype: Dtype | None = None, copy: bool = False, verify_integrity: bool = True): ...
    @classmethod
    def from_breaks(cls, breaks, closed: IntervalClosedType | None = 'right', copy: bool = False, dtype: Dtype | None = None) -> Self: ...
    @classmethod
    def from_arrays(cls, left, right, closed: IntervalClosedType | None = 'right', copy: bool = False, dtype: Dtype | None = None) -> Self: ...
    @classmethod
    def from_tuples(cls, data, closed: IntervalClosedType | None = 'right', copy: bool = False, dtype: Dtype | None = None) -> Self: ...
    @property
    def dtype(self) -> IntervalDtype: ...
    @property
    def nbytes(self) -> int: ...
    @property
    def size(self) -> int: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, key: ScalarIndexer) -> IntervalOrNA: ...
    @overload
    def __getitem__(self, key: SequenceIndexer) -> Self: ...
    def __setitem__(self, key, value) -> None: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def argsort(self, *, ascending: bool = True, kind: SortKind = 'quicksort', na_position: str = 'last', **kwargs) -> np.ndarray: ...
    def min(self, *, axis: AxisInt | None = None, skipna: bool = True) -> IntervalOrNA: ...
    def max(self, *, axis: AxisInt | None = None, skipna: bool = True) -> IntervalOrNA: ...
    def fillna(self, value: Incomplete | None = None, method: Incomplete | None = None, limit: int | None = None, copy: bool = True) -> Self: ...
    def astype(self, dtype, copy: bool = True): ...
    def equals(self, other) -> bool: ...
    def copy(self) -> Self: ...
    def isna(self) -> np.ndarray: ...
    def shift(self, periods: int = 1, fill_value: object = None) -> IntervalArray: ...
    def take(self, indices, *, allow_fill: bool = False, fill_value: Incomplete | None = None, axis: Incomplete | None = None, **kwargs) -> Self: ...
    def value_counts(self, dropna: bool = True) -> Series: ...
    @property
    def left(self) -> Index: ...
    @property
    def right(self) -> Index: ...
    @property
    def length(self) -> Index: ...
    @property
    def mid(self) -> Index: ...
    def overlaps(self, other): ...
    @property
    def closed(self) -> IntervalClosedType: ...
    def set_closed(self, closed: IntervalClosedType) -> Self: ...
    @property
    def is_non_overlapping_monotonic(self) -> bool: ...
    def __array__(self, dtype: NpDtype | None = None, copy: bool | None = None) -> np.ndarray: ...
    def __arrow_array__(self, type: Incomplete | None = None): ...
    def to_tuples(self, na_tuple: bool = True) -> np.ndarray: ...
    def insert(self, loc: int, item: Interval) -> Self: ...
    def delete(self, loc) -> Self: ...
    def repeat(self, repeats: int | Sequence[int], axis: AxisInt | None = None) -> Self: ...
    def contains(self, other): ...
    def isin(self, values: ArrayLike) -> npt.NDArray[np.bool_]: ...
    def unique(self) -> IntervalArray: ...
