import numpy as np
from _typeshed import Incomplete
from collections.abc import Hashable, Mapping, Sequence
from pandas import Categorical as Categorical
from pandas._libs import Interval as Interval, lib as lib
from pandas._libs.hashtable import duplicated as duplicated
from pandas._typing import ArrayLike as ArrayLike, Axis as Axis, AxisInt as AxisInt, CorrelationMethod as CorrelationMethod, FillnaOptions as FillnaOptions, IndexLabel as IndexLabel, Manager as Manager, Manager2D as Manager2D, SingleManager as SingleManager, TakeIndexer as TakeIndexer
from pandas.core import algorithms as algorithms
from pandas.core.apply import GroupByApply as GroupByApply, maybe_mangle_lambdas as maybe_mangle_lambdas, reconstruct_func as reconstruct_func, validate_func_kwargs as validate_func_kwargs, warn_alias_replacement as warn_alias_replacement
from pandas.core.dtypes.common import ensure_int64 as ensure_int64, is_bool as is_bool, is_dict_like as is_dict_like, is_integer_dtype as is_integer_dtype, is_list_like as is_list_like, is_numeric_dtype as is_numeric_dtype, is_scalar as is_scalar
from pandas.core.dtypes.dtypes import CategoricalDtype as CategoricalDtype, IntervalDtype as IntervalDtype
from pandas.core.dtypes.inference import is_hashable as is_hashable
from pandas.core.dtypes.missing import isna as isna, notna as notna
from pandas.core.frame import DataFrame as DataFrame
from pandas.core.generic import NDFrame as NDFrame
from pandas.core.groupby import base as base, ops as ops
from pandas.core.groupby.groupby import GroupBy as GroupBy, GroupByPlot as GroupByPlot
from pandas.core.indexes.api import Index as Index, MultiIndex as MultiIndex, all_indexes_same as all_indexes_same, default_index as default_index
from pandas.core.series import Series as Series
from pandas.core.sorting import get_group_index as get_group_index
from pandas.core.util.numba_ import maybe_use_numba as maybe_use_numba
from pandas.errors import SpecificationError as SpecificationError
from pandas.plotting import boxplot_frame_groupby as boxplot_frame_groupby
from pandas.util._decorators import Appender as Appender, Substitution as Substitution, doc as doc
from pandas.util._exceptions import find_stack_level as find_stack_level
from typing import Any, Callable, Literal, NamedTuple, TypeVar

AggScalar = str | Callable[..., Any]
ScalarResult = TypeVar('ScalarResult')

class NamedAgg(NamedTuple):
    column: Hashable
    aggfunc: AggScalar

class SeriesGroupBy(GroupBy[Series]):
    def apply(self, func, *args, **kwargs) -> Series: ...
    def aggregate(self, func: Incomplete | None = None, *args, engine: Incomplete | None = None, engine_kwargs: Incomplete | None = None, **kwargs): ...
    agg = aggregate
    def transform(self, func, *args, engine: Incomplete | None = None, engine_kwargs: Incomplete | None = None, **kwargs): ...
    def filter(self, func, dropna: bool = True, *args, **kwargs): ...
    def nunique(self, dropna: bool = True) -> Series | DataFrame: ...
    def describe(self, percentiles: Incomplete | None = None, include: Incomplete | None = None, exclude: Incomplete | None = None) -> Series: ...
    def value_counts(self, normalize: bool = False, sort: bool = True, ascending: bool = False, bins: Incomplete | None = None, dropna: bool = True) -> Series | DataFrame: ...
    def fillna(self, value: object | ArrayLike | None = None, method: FillnaOptions | None = None, axis: Axis | None | lib.NoDefault = ..., inplace: bool = False, limit: int | None = None, downcast: dict | None | lib.NoDefault = ...) -> Series | None: ...
    def take(self, indices: TakeIndexer, axis: Axis | lib.NoDefault = ..., **kwargs) -> Series: ...
    def skew(self, axis: Axis | lib.NoDefault = ..., skipna: bool = True, numeric_only: bool = False, **kwargs) -> Series: ...
    @property
    def plot(self) -> GroupByPlot: ...
    def nlargest(self, n: int = 5, keep: Literal['first', 'last', 'all'] = 'first') -> Series: ...
    def nsmallest(self, n: int = 5, keep: Literal['first', 'last', 'all'] = 'first') -> Series: ...
    def idxmin(self, axis: Axis | lib.NoDefault = ..., skipna: bool = True) -> Series: ...
    def idxmax(self, axis: Axis | lib.NoDefault = ..., skipna: bool = True) -> Series: ...
    def corr(self, other: Series, method: CorrelationMethod = 'pearson', min_periods: int | None = None) -> Series: ...
    def cov(self, other: Series, min_periods: int | None = None, ddof: int | None = 1) -> Series: ...
    @property
    def is_monotonic_increasing(self) -> Series: ...
    @property
    def is_monotonic_decreasing(self) -> Series: ...
    def hist(self, by: Incomplete | None = None, ax: Incomplete | None = None, grid: bool = True, xlabelsize: int | None = None, xrot: float | None = None, ylabelsize: int | None = None, yrot: float | None = None, figsize: tuple[int, int] | None = None, bins: int | Sequence[int] = 10, backend: str | None = None, legend: bool = False, **kwargs): ...
    @property
    def dtype(self) -> Series: ...
    def unique(self) -> Series: ...

class DataFrameGroupBy(GroupBy[DataFrame]):
    def aggregate(self, func: Incomplete | None = None, *args, engine: Incomplete | None = None, engine_kwargs: Incomplete | None = None, **kwargs): ...
    agg = aggregate
    def transform(self, func, *args, engine: Incomplete | None = None, engine_kwargs: Incomplete | None = None, **kwargs): ...
    def filter(self, func, dropna: bool = True, *args, **kwargs): ...
    def __getitem__(self, key) -> DataFrameGroupBy | SeriesGroupBy: ...
    def nunique(self, dropna: bool = True) -> DataFrame: ...
    def idxmax(self, axis: Axis | None | lib.NoDefault = ..., skipna: bool = True, numeric_only: bool = False) -> DataFrame: ...
    def idxmin(self, axis: Axis | None | lib.NoDefault = ..., skipna: bool = True, numeric_only: bool = False) -> DataFrame: ...
    boxplot = boxplot_frame_groupby
    def value_counts(self, subset: Sequence[Hashable] | None = None, normalize: bool = False, sort: bool = True, ascending: bool = False, dropna: bool = True) -> DataFrame | Series: ...
    def fillna(self, value: Hashable | Mapping | Series | DataFrame | None = None, method: FillnaOptions | None = None, axis: Axis | None | lib.NoDefault = ..., inplace: bool = False, limit: int | None = None, downcast=...) -> DataFrame | None: ...
    def take(self, indices: TakeIndexer, axis: Axis | None | lib.NoDefault = ..., **kwargs) -> DataFrame: ...
    def skew(self, axis: Axis | None | lib.NoDefault = ..., skipna: bool = True, numeric_only: bool = False, **kwargs) -> DataFrame: ...
    @property
    def plot(self) -> GroupByPlot: ...
    def corr(self, method: str | Callable[[np.ndarray, np.ndarray], float] = 'pearson', min_periods: int = 1, numeric_only: bool = False) -> DataFrame: ...
    def cov(self, min_periods: int | None = None, ddof: int | None = 1, numeric_only: bool = False) -> DataFrame: ...
    def hist(self, column: IndexLabel | None = None, by: Incomplete | None = None, grid: bool = True, xlabelsize: int | None = None, xrot: float | None = None, ylabelsize: int | None = None, yrot: float | None = None, ax: Incomplete | None = None, sharex: bool = False, sharey: bool = False, figsize: tuple[int, int] | None = None, layout: tuple[int, int] | None = None, bins: int | Sequence[int] = 10, backend: str | None = None, legend: bool = False, **kwargs): ...
    @property
    def dtypes(self) -> Series: ...
    def corrwith(self, other: DataFrame | Series, axis: Axis | lib.NoDefault = ..., drop: bool = False, method: CorrelationMethod = 'pearson', numeric_only: bool = False) -> DataFrame: ...
