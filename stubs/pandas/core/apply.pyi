import abc
import numpy as np
from _typeshed import Incomplete
from collections.abc import Generator, Hashable, Iterable, MutableMapping, Sequence
from pandas import DataFrame as DataFrame, Index as Index, Series as Series
from pandas._config import option_context as option_context
from pandas._libs import lib as lib
from pandas._libs.internals import BlockValuesRefs as BlockValuesRefs
from pandas._typing import AggFuncType as AggFuncType, AggFuncTypeBase as AggFuncTypeBase, AggFuncTypeDict as AggFuncTypeDict, AggObjType as AggObjType, Axis as Axis, AxisInt as AxisInt, NDFrameT as NDFrameT, npt as npt
from pandas.compat._optional import import_optional_dependency as import_optional_dependency
from pandas.core._numba.executor import generate_apply_looper as generate_apply_looper
from pandas.core.construction import ensure_wrapped_if_datetimelike as ensure_wrapped_if_datetimelike
from pandas.core.dtypes.cast import is_nested_object as is_nested_object
from pandas.core.dtypes.common import is_dict_like as is_dict_like, is_extension_array_dtype as is_extension_array_dtype, is_list_like as is_list_like, is_numeric_dtype as is_numeric_dtype, is_sequence as is_sequence
from pandas.core.dtypes.dtypes import CategoricalDtype as CategoricalDtype, ExtensionDtype as ExtensionDtype
from pandas.core.dtypes.generic import ABCDataFrame as ABCDataFrame, ABCNDFrame as ABCNDFrame, ABCSeries as ABCSeries
from pandas.core.groupby import GroupBy as GroupBy
from pandas.core.resample import Resampler as Resampler
from pandas.core.window.rolling import BaseWindow as BaseWindow
from pandas.errors import SpecificationError as SpecificationError
from pandas.util._decorators import cache_readonly as cache_readonly
from pandas.util._exceptions import find_stack_level as find_stack_level
from typing import Any, Callable, Literal

ResType = dict[int, Any]

def frame_apply(obj: DataFrame, func: AggFuncType, axis: Axis = 0, raw: bool = False, result_type: str | None = None, by_row: Literal[False, 'compat'] = 'compat', engine: str = 'python', engine_kwargs: dict[str, bool] | None = None, args: Incomplete | None = None, kwargs: Incomplete | None = None) -> FrameApply: ...

class Apply(metaclass=abc.ABCMeta):
    axis: AxisInt
    obj: Incomplete
    raw: Incomplete
    by_row: Incomplete
    args: Incomplete
    kwargs: Incomplete
    engine: Incomplete
    engine_kwargs: Incomplete
    result_type: Incomplete
    func: Incomplete
    def __init__(self, obj: AggObjType, func: AggFuncType, raw: bool, result_type: str | None, *, by_row: Literal[False, 'compat', '_compat'] = 'compat', engine: str = 'python', engine_kwargs: dict[str, bool] | None = None, args, kwargs) -> None: ...
    @abc.abstractmethod
    def apply(self) -> DataFrame | Series: ...
    @abc.abstractmethod
    def agg_or_apply_list_like(self, op_name: Literal['agg', 'apply']) -> DataFrame | Series: ...
    @abc.abstractmethod
    def agg_or_apply_dict_like(self, op_name: Literal['agg', 'apply']) -> DataFrame | Series: ...
    def agg(self) -> DataFrame | Series | None: ...
    def transform(self) -> DataFrame | Series: ...
    def transform_dict_like(self, func) -> DataFrame: ...
    def transform_str_or_callable(self, func) -> DataFrame | Series: ...
    def agg_list_like(self) -> DataFrame | Series: ...
    def compute_list_like(self, op_name: Literal['agg', 'apply'], selected_obj: Series | DataFrame, kwargs: dict[str, Any]) -> tuple[list[Hashable] | Index, list[Any]]: ...
    def wrap_results_list_like(self, keys: Iterable[Hashable], results: list[Series | DataFrame]): ...
    def agg_dict_like(self) -> DataFrame | Series: ...
    def compute_dict_like(self, op_name: Literal['agg', 'apply'], selected_obj: Series | DataFrame, selection: Hashable | Sequence[Hashable], kwargs: dict[str, Any]) -> tuple[list[Hashable], list[Any]]: ...
    def wrap_results_dict_like(self, selected_obj: Series | DataFrame, result_index: list[Hashable], result_data: list): ...
    def apply_str(self) -> DataFrame | Series: ...
    def apply_list_or_dict_like(self) -> DataFrame | Series: ...
    def normalize_dictlike_arg(self, how: str, obj: DataFrame | Series, func: AggFuncTypeDict) -> AggFuncTypeDict: ...

class NDFrameApply(Apply, metaclass=abc.ABCMeta):
    obj: DataFrame | Series
    @property
    def index(self) -> Index: ...
    @property
    def agg_axis(self) -> Index: ...
    def agg_or_apply_list_like(self, op_name: Literal['agg', 'apply']) -> DataFrame | Series: ...
    def agg_or_apply_dict_like(self, op_name: Literal['agg', 'apply']) -> DataFrame | Series: ...

class FrameApply(NDFrameApply, metaclass=abc.ABCMeta):
    obj: DataFrame
    def __init__(self, obj: AggObjType, func: AggFuncType, raw: bool, result_type: str | None, *, by_row: Literal[False, 'compat'] = False, engine: str = 'python', engine_kwargs: dict[str, bool] | None = None, args, kwargs) -> None: ...
    @property
    @abc.abstractmethod
    def result_index(self) -> Index: ...
    @property
    @abc.abstractmethod
    def result_columns(self) -> Index: ...
    @property
    @abc.abstractmethod
    def series_generator(self) -> Generator[Series, None, None]: ...
    @staticmethod
    @abc.abstractmethod
    def generate_numba_apply_func(func, nogil: bool = True, nopython: bool = True, parallel: bool = False) -> Callable[[npt.NDArray, Index, Index], dict[int, Any]]: ...
    @abc.abstractmethod
    def apply_with_numba(self): ...
    def validate_values_for_numba(self) -> None: ...
    @abc.abstractmethod
    def wrap_results_for_axis(self, results: ResType, res_index: Index) -> DataFrame | Series: ...
    @property
    def res_columns(self) -> Index: ...
    @property
    def columns(self) -> Index: ...
    def values(self): ...
    def apply(self) -> DataFrame | Series: ...
    axis: int
    def agg(self): ...
    def apply_empty_result(self): ...
    def apply_raw(self, engine: str = 'python', engine_kwargs: Incomplete | None = None): ...
    def apply_broadcast(self, target: DataFrame) -> DataFrame: ...
    def apply_standard(self): ...
    def apply_series_generator(self) -> tuple[ResType, Index]: ...
    def apply_series_numba(self): ...
    def wrap_results(self, results: ResType, res_index: Index) -> DataFrame | Series: ...
    def apply_str(self) -> DataFrame | Series: ...

class FrameRowApply(FrameApply):
    axis: AxisInt
    @property
    def series_generator(self) -> Generator[Series, None, None]: ...
    @staticmethod
    def generate_numba_apply_func(func, nogil: bool = True, nopython: bool = True, parallel: bool = False) -> Callable[[npt.NDArray, Index, Index], dict[int, Any]]: ...
    def apply_with_numba(self) -> dict[int, Any]: ...
    @property
    def result_index(self) -> Index: ...
    @property
    def result_columns(self) -> Index: ...
    def wrap_results_for_axis(self, results: ResType, res_index: Index) -> DataFrame | Series: ...

class FrameColumnApply(FrameApply):
    axis: AxisInt
    def apply_broadcast(self, target: DataFrame) -> DataFrame: ...
    @property
    def series_generator(self) -> Generator[Series, None, None]: ...
    @staticmethod
    def generate_numba_apply_func(func, nogil: bool = True, nopython: bool = True, parallel: bool = False) -> Callable[[npt.NDArray, Index, Index], dict[int, Any]]: ...
    def apply_with_numba(self) -> dict[int, Any]: ...
    @property
    def result_index(self) -> Index: ...
    @property
    def result_columns(self) -> Index: ...
    def wrap_results_for_axis(self, results: ResType, res_index: Index) -> DataFrame | Series: ...
    def infer_to_same_shape(self, results: ResType, res_index: Index) -> DataFrame: ...

class SeriesApply(NDFrameApply):
    obj: Series
    axis: AxisInt
    by_row: Literal[False, 'compat', '_compat']
    convert_dtype: Incomplete
    def __init__(self, obj: Series, func: AggFuncType, *, convert_dtype: bool | lib.NoDefault = ..., by_row: Literal[False, 'compat', '_compat'] = 'compat', args, kwargs) -> None: ...
    def apply(self) -> DataFrame | Series: ...
    def agg(self): ...
    def apply_empty_result(self) -> Series: ...
    def apply_compat(self): ...
    def apply_standard(self) -> DataFrame | Series: ...

class GroupByApply(Apply):
    obj: GroupBy | Resampler | BaseWindow
    axis: Incomplete
    def __init__(self, obj: GroupBy[NDFrameT], func: AggFuncType, *, args, kwargs) -> None: ...
    def apply(self) -> None: ...
    def transform(self) -> None: ...
    def agg_or_apply_list_like(self, op_name: Literal['agg', 'apply']) -> DataFrame | Series: ...
    def agg_or_apply_dict_like(self, op_name: Literal['agg', 'apply']) -> DataFrame | Series: ...

class ResamplerWindowApply(GroupByApply):
    axis: AxisInt
    obj: Resampler | BaseWindow
    def __init__(self, obj: Resampler | BaseWindow, func: AggFuncType, *, args, kwargs) -> None: ...
    def apply(self) -> None: ...
    def transform(self) -> None: ...

def reconstruct_func(func: AggFuncType | None, **kwargs) -> tuple[bool, AggFuncType, tuple[str, ...] | None, npt.NDArray[np.intp] | None]: ...
def is_multi_agg_with_relabel(**kwargs) -> bool: ...
def normalize_keyword_aggregation(kwargs: dict) -> tuple[MutableMapping[Hashable, list[AggFuncTypeBase]], tuple[str, ...], npt.NDArray[np.intp]]: ...
def relabel_result(result: DataFrame | Series, func: dict[str, list[Callable | str]], columns: Iterable[Hashable], order: Iterable[int]) -> dict[Hashable, Series]: ...
def reconstruct_and_relabel_result(result, func, **kwargs) -> DataFrame | Series: ...
def maybe_mangle_lambdas(agg_spec: Any) -> Any: ...
def validate_func_kwargs(kwargs: dict) -> tuple[list[str], list[str | Callable[..., Any]]]: ...
def include_axis(op_name: Literal['agg', 'apply'], colg: Series | DataFrame) -> bool: ...
def warn_alias_replacement(obj: AggObjType, func: Callable, alias: str) -> None: ...
