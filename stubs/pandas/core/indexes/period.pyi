import numpy as np
from _typeshed import Incomplete
from collections.abc import Hashable
from pandas._libs.tslibs import BaseOffset as BaseOffset, NaT as NaT, Period as Period, Resolution as Resolution, Tick as Tick
from pandas._libs.tslibs.dtypes import OFFSET_TO_PERIOD_FREQSTR as OFFSET_TO_PERIOD_FREQSTR
from pandas._typing import Dtype as Dtype, DtypeObj as DtypeObj, Self as Self, npt as npt
from pandas.core.arrays.period import PeriodArray as PeriodArray, period_array as period_array, raise_on_incompatible as raise_on_incompatible, validate_dtype_freq as validate_dtype_freq
from pandas.core.dtypes.common import is_integer as is_integer
from pandas.core.dtypes.dtypes import PeriodDtype as PeriodDtype
from pandas.core.dtypes.generic import ABCSeries as ABCSeries
from pandas.core.dtypes.missing import is_valid_na_for_dtype as is_valid_na_for_dtype
from pandas.core.indexes.base import maybe_extract_name as maybe_extract_name
from pandas.core.indexes.datetimelike import DatetimeIndexOpsMixin as DatetimeIndexOpsMixin
from pandas.core.indexes.datetimes import DatetimeIndex as DatetimeIndex, Index as Index
from pandas.core.indexes.extension import inherit_names as inherit_names
from pandas.util._decorators import cache_readonly as cache_readonly, doc as doc
from pandas.util._exceptions import find_stack_level as find_stack_level

class PeriodIndex(DatetimeIndexOpsMixin):
    freq: BaseOffset
    dtype: PeriodDtype
    def asfreq(self, freq: Incomplete | None = None, how: str = 'E') -> Self: ...
    def to_timestamp(self, freq: Incomplete | None = None, how: str = 'start') -> DatetimeIndex: ...
    @property
    def hour(self) -> Index: ...
    @property
    def minute(self) -> Index: ...
    @property
    def second(self) -> Index: ...
    def __new__(cls, data: Incomplete | None = None, ordinal: Incomplete | None = None, freq: Incomplete | None = None, dtype: Dtype | None = None, copy: bool = False, name: Hashable | None = None, **fields) -> Self: ...
    @classmethod
    def from_fields(cls, *, year: Incomplete | None = None, quarter: Incomplete | None = None, month: Incomplete | None = None, day: Incomplete | None = None, hour: Incomplete | None = None, minute: Incomplete | None = None, second: Incomplete | None = None, freq: Incomplete | None = None) -> Self: ...
    @classmethod
    def from_ordinals(cls, ordinals, *, freq, name: Incomplete | None = None) -> Self: ...
    @property
    def values(self) -> npt.NDArray[np.object_]: ...
    def asof_locs(self, where: Index, mask: npt.NDArray[np.bool_]) -> np.ndarray: ...
    @property
    def is_full(self) -> bool: ...
    @property
    def inferred_type(self) -> str: ...
    def get_loc(self, key): ...
    def shift(self, periods: int = 1, freq: Incomplete | None = None) -> Self: ...

def period_range(start: Incomplete | None = None, end: Incomplete | None = None, periods: int | None = None, freq: Incomplete | None = None, name: Hashable | None = None) -> PeriodIndex: ...
