import numpy as np
from _typeshed import Incomplete
from collections.abc import Hashable, Iterable, Sequence
from pandas import CategoricalIndex as CategoricalIndex, DataFrame as DataFrame, Series as Series
from pandas._config import get_option as get_option
from pandas._libs import index as libindex, lib as lib
from pandas._libs.hashtable import duplicated as duplicated
from pandas._typing import AnyAll as AnyAll, AnyArrayLike as AnyArrayLike, Axis as Axis, DropKeep as DropKeep, DtypeObj as DtypeObj, F as F, IgnoreRaise as IgnoreRaise, IndexLabel as IndexLabel, Scalar as Scalar, Self as Self, Shape as Shape, npt as npt
from pandas.core.array_algos.putmask import validate_putmask as validate_putmask
from pandas.core.arrays import Categorical as Categorical, ExtensionArray as ExtensionArray
from pandas.core.arrays.categorical import factorize_from_iterables as factorize_from_iterables, recode_for_categories as recode_for_categories
from pandas.core.construction import sanitize_array as sanitize_array
from pandas.core.dtypes.cast import coerce_indexer_dtype as coerce_indexer_dtype
from pandas.core.dtypes.common import ensure_int64 as ensure_int64, ensure_platform_int as ensure_platform_int, is_hashable as is_hashable, is_integer as is_integer, is_iterator as is_iterator, is_list_like as is_list_like, is_object_dtype as is_object_dtype, is_scalar as is_scalar, pandas_dtype as pandas_dtype
from pandas.core.dtypes.dtypes import CategoricalDtype as CategoricalDtype, ExtensionDtype as ExtensionDtype
from pandas.core.dtypes.generic import ABCDataFrame as ABCDataFrame, ABCSeries as ABCSeries
from pandas.core.dtypes.inference import is_array_like as is_array_like
from pandas.core.dtypes.missing import array_equivalent as array_equivalent, isna as isna
from pandas.core.indexes.base import Index as Index, ensure_index as ensure_index, get_unanimous_names as get_unanimous_names
from pandas.core.indexes.frozen import FrozenList as FrozenList
from pandas.core.ops.invalid import make_invalid_op as make_invalid_op
from pandas.core.sorting import get_group_index as get_group_index, lexsort_indexer as lexsort_indexer
from pandas.errors import InvalidIndexError as InvalidIndexError, PerformanceWarning as PerformanceWarning, UnsortedIndexError as UnsortedIndexError
from pandas.io.formats.printing import get_adjustment as get_adjustment, pprint_thing as pprint_thing
from pandas.util._decorators import Appender as Appender, cache_readonly as cache_readonly, doc as doc
from pandas.util._exceptions import find_stack_level as find_stack_level
from typing import Any, Callable, Literal

class MultiIndexUIntEngine(libindex.BaseMultiIndexCodesEngine, libindex.UInt64Engine): ...
class MultiIndexPyIntEngine(libindex.BaseMultiIndexCodesEngine, libindex.ObjectEngine): ...

def names_compat(meth: F) -> F: ...

class MultiIndex(Index):
    sortorder: int | None
    def __new__(cls, levels: Incomplete | None = None, codes: Incomplete | None = None, sortorder: Incomplete | None = None, names: Incomplete | None = None, dtype: Incomplete | None = None, copy: bool = False, name: Incomplete | None = None, verify_integrity: bool = True) -> Self: ...
    @classmethod
    def from_arrays(cls, arrays, sortorder: int | None = None, names: Sequence[Hashable] | Hashable | lib.NoDefault = ...) -> MultiIndex: ...
    @classmethod
    def from_tuples(cls, tuples: Iterable[tuple[Hashable, ...]], sortorder: int | None = None, names: Sequence[Hashable] | Hashable | None = None) -> MultiIndex: ...
    @classmethod
    def from_product(cls, iterables: Sequence[Iterable[Hashable]], sortorder: int | None = None, names: Sequence[Hashable] | Hashable | lib.NoDefault = ...) -> MultiIndex: ...
    @classmethod
    def from_frame(cls, df: DataFrame, sortorder: int | None = None, names: Sequence[Hashable] | Hashable | None = None) -> MultiIndex: ...
    @property
    def values(self) -> np.ndarray: ...
    @property
    def array(self) -> None: ...
    def dtypes(self) -> Series: ...
    def __len__(self) -> int: ...
    @property
    def size(self) -> int: ...
    def levels(self) -> FrozenList: ...
    def set_levels(self, levels, *, level: Incomplete | None = None, verify_integrity: bool = True) -> MultiIndex: ...
    @property
    def nlevels(self) -> int: ...
    @property
    def levshape(self) -> Shape: ...
    @property
    def codes(self) -> FrozenList: ...
    def set_codes(self, codes, *, level: Incomplete | None = None, verify_integrity: bool = True) -> MultiIndex: ...
    def copy(self, names: Incomplete | None = None, deep: bool = False, name: Incomplete | None = None) -> Self: ...
    def __array__(self, dtype: Incomplete | None = None, copy: Incomplete | None = None) -> np.ndarray: ...
    def view(self, cls: Incomplete | None = None) -> Self: ...
    def __contains__(self, key: Any) -> bool: ...
    def dtype(self) -> np.dtype: ...
    def memory_usage(self, deep: bool = False) -> int: ...
    def nbytes(self) -> int: ...
    def format(self, name: bool | None = None, formatter: Callable | None = None, na_rep: str | None = None, names: bool = False, space: int = 2, sparsify: Incomplete | None = None, adjoin: bool = True) -> list: ...
    names: Incomplete
    def inferred_type(self) -> str: ...
    def is_monotonic_increasing(self) -> bool: ...
    def is_monotonic_decreasing(self) -> bool: ...
    def duplicated(self, keep: DropKeep = 'first') -> npt.NDArray[np.bool_]: ...
    def fillna(self, value: Incomplete | None = None, downcast: Incomplete | None = None) -> None: ...
    def dropna(self, how: AnyAll = 'any') -> MultiIndex: ...
    def get_level_values(self, level) -> Index: ...
    def unique(self, level: Incomplete | None = None): ...
    def to_frame(self, index: bool = True, name=..., allow_duplicates: bool = False) -> DataFrame: ...
    def to_flat_index(self) -> Index: ...
    def remove_unused_levels(self) -> MultiIndex: ...
    def __reduce__(self): ...
    def __getitem__(self, key): ...
    def take(self, indices, axis: Axis = 0, allow_fill: bool = True, fill_value: Incomplete | None = None, **kwargs) -> MultiIndex: ...
    def append(self, other): ...
    def argsort(self, *args, na_position: str = 'last', **kwargs) -> npt.NDArray[np.intp]: ...
    def repeat(self, repeats: int, axis: Incomplete | None = None) -> MultiIndex: ...
    def drop(self, codes, level: Index | np.ndarray | Iterable[Hashable] | None = None, errors: IgnoreRaise = 'raise') -> MultiIndex: ...
    def swaplevel(self, i: int = -2, j: int = -1) -> MultiIndex: ...
    def reorder_levels(self, order) -> MultiIndex: ...
    def sortlevel(self, level: IndexLabel = 0, ascending: bool | list[bool] = True, sort_remaining: bool = True, na_position: str = 'first') -> tuple[MultiIndex, npt.NDArray[np.intp]]: ...
    def get_slice_bound(self, label: Hashable | Sequence[Hashable], side: Literal['left', 'right']) -> int: ...
    def slice_locs(self, start: Incomplete | None = None, end: Incomplete | None = None, step: Incomplete | None = None) -> tuple[int, int]: ...
    def get_loc(self, key): ...
    def get_loc_level(self, key, level: IndexLabel = 0, drop_level: bool = True): ...
    def get_locs(self, seq) -> npt.NDArray[np.intp]: ...
    def truncate(self, before: Incomplete | None = None, after: Incomplete | None = None) -> MultiIndex: ...
    def equals(self, other: object) -> bool: ...
    def equal_levels(self, other: MultiIndex) -> bool: ...
    def astype(self, dtype, copy: bool = True): ...
    def putmask(self, mask, value: MultiIndex) -> MultiIndex: ...
    def insert(self, loc: int, item) -> MultiIndex: ...
    def delete(self, loc) -> MultiIndex: ...
    def isin(self, values, level: Incomplete | None = None) -> npt.NDArray[np.bool_]: ...
    rename: Incomplete
    __add__: Incomplete
    __radd__: Incomplete
    __iadd__: Incomplete
    __sub__: Incomplete
    __rsub__: Incomplete
    __isub__: Incomplete
    __pow__: Incomplete
    __rpow__: Incomplete
    __mul__: Incomplete
    __rmul__: Incomplete
    __floordiv__: Incomplete
    __rfloordiv__: Incomplete
    __truediv__: Incomplete
    __rtruediv__: Incomplete
    __mod__: Incomplete
    __rmod__: Incomplete
    __divmod__: Incomplete
    __rdivmod__: Incomplete
    __neg__: Incomplete
    __pos__: Incomplete
    __abs__: Incomplete
    __invert__: Incomplete

def sparsify_labels(label_list, start: int = 0, sentinel: object = ''): ...
def maybe_droplevels(index: Index, key) -> Index: ...
