import numpy as np
from _typeshed import Incomplete
from collections.abc import Hashable, Iterator
from pandas._libs import lib as lib
from pandas._libs.algos import unique_deltas as unique_deltas
from pandas._libs.lib import no_default as no_default
from pandas._typing import Axis as Axis, Dtype as Dtype, NaPosition as NaPosition, Self as Self, npt as npt
from pandas.core import ops as ops
from pandas.core.construction import extract_array as extract_array
from pandas.core.dtypes.common import ensure_platform_int as ensure_platform_int, ensure_python_int as ensure_python_int, is_float as is_float, is_integer as is_integer, is_scalar as is_scalar, is_signed_integer_dtype as is_signed_integer_dtype
from pandas.core.dtypes.generic import ABCTimedeltaIndex as ABCTimedeltaIndex
from pandas.core.indexes.base import Index as Index, maybe_extract_name as maybe_extract_name
from pandas.core.ops.common import unpack_zerodim_and_defer as unpack_zerodim_and_defer
from pandas.util._decorators import cache_readonly as cache_readonly, deprecate_nonkeyword_arguments as deprecate_nonkeyword_arguments, doc as doc
from typing import Any, Callable, Literal, overload

class RangeIndex(Index):
    def __new__(cls, start: Incomplete | None = None, stop: Incomplete | None = None, step: Incomplete | None = None, dtype: Dtype | None = None, copy: bool = False, name: Hashable | None = None) -> Self: ...
    @classmethod
    def from_range(cls, data: range, name: Incomplete | None = None, dtype: Dtype | None = None) -> Self: ...
    def __reduce__(self): ...
    @property
    def start(self) -> int: ...
    @property
    def stop(self) -> int: ...
    @property
    def step(self) -> int: ...
    def nbytes(self) -> int: ...
    def memory_usage(self, deep: bool = False) -> int: ...
    @property
    def dtype(self) -> np.dtype: ...
    @property
    def is_unique(self) -> bool: ...
    def is_monotonic_increasing(self) -> bool: ...
    def is_monotonic_decreasing(self) -> bool: ...
    def __contains__(self, key: Any) -> bool: ...
    @property
    def inferred_type(self) -> str: ...
    def get_loc(self, key) -> int: ...
    def tolist(self) -> list[int]: ...
    def __iter__(self) -> Iterator[int]: ...
    def copy(self, name: Hashable | None = None, deep: bool = False) -> Self: ...
    def min(self, axis: Incomplete | None = None, skipna: bool = True, *args, **kwargs) -> int: ...
    def max(self, axis: Incomplete | None = None, skipna: bool = True, *args, **kwargs) -> int: ...
    def argsort(self, *args, **kwargs) -> npt.NDArray[np.intp]: ...
    def factorize(self, sort: bool = False, use_na_sentinel: bool = True) -> tuple[npt.NDArray[np.intp], RangeIndex]: ...
    def equals(self, other: object) -> bool: ...
    @overload
    def sort_values(self, *, return_indexer: Literal[False] = ..., ascending: bool = ..., na_position: NaPosition = ..., key: Callable | None = ...) -> Self: ...
    @overload
    def sort_values(self, *, return_indexer: Literal[True], ascending: bool = ..., na_position: NaPosition = ..., key: Callable | None = ...) -> tuple[Self, np.ndarray | RangeIndex]: ...
    @overload
    def sort_values(self, *, return_indexer: bool = ..., ascending: bool = ..., na_position: NaPosition = ..., key: Callable | None = ...) -> Self | tuple[Self, np.ndarray | RangeIndex]: ...
    def symmetric_difference(self, other, result_name: Hashable | None = None, sort: Incomplete | None = None): ...
    def delete(self, loc) -> Index: ...
    def insert(self, loc: int, item) -> Index: ...
    def __len__(self) -> int: ...
    @property
    def size(self) -> int: ...
    def __getitem__(self, key): ...
    def __floordiv__(self, other): ...
    def all(self, *args, **kwargs) -> bool: ...
    def any(self, *args, **kwargs) -> bool: ...
    def take(self, indices, axis: Axis = 0, allow_fill: bool = True, fill_value: Incomplete | None = None, **kwargs) -> Index: ...
