import datetime as dt
import numpy as np
from _typeshed import Incomplete
from collections.abc import Hashable
from pandas._libs import NaT as NaT, Period as Period, Timestamp as Timestamp, lib as lib
from pandas._libs.tslibs import Resolution as Resolution, Tick as Tick, Timedelta as Timedelta, periods_per_day as periods_per_day, timezones as timezones, to_offset as to_offset
from pandas._libs.tslibs.dtypes import OFFSET_TO_PERIOD_FREQSTR as OFFSET_TO_PERIOD_FREQSTR
from pandas._libs.tslibs.offsets import prefix_mapping as prefix_mapping
from pandas._typing import Dtype as Dtype, DtypeObj as DtypeObj, Frequency as Frequency, IntervalClosedType as IntervalClosedType, Self as Self, TimeAmbiguous as TimeAmbiguous, TimeNonexistent as TimeNonexistent, npt as npt
from pandas.core.api import DataFrame as DataFrame, PeriodIndex as PeriodIndex
from pandas.core.arrays.datetimes import DatetimeArray as DatetimeArray, tz_to_dtype as tz_to_dtype
from pandas.core.dtypes.common import is_scalar as is_scalar
from pandas.core.dtypes.dtypes import DatetimeTZDtype as DatetimeTZDtype
from pandas.core.dtypes.generic import ABCSeries as ABCSeries
from pandas.core.dtypes.missing import is_valid_na_for_dtype as is_valid_na_for_dtype
from pandas.core.indexes.base import Index as Index, maybe_extract_name as maybe_extract_name
from pandas.core.indexes.datetimelike import DatetimeTimedeltaMixin as DatetimeTimedeltaMixin
from pandas.core.indexes.extension import inherit_names as inherit_names
from pandas.core.tools.times import to_time as to_time
from pandas.util._decorators import cache_readonly as cache_readonly, doc as doc
from pandas.util._exceptions import find_stack_level as find_stack_level

class DatetimeIndex(DatetimeTimedeltaMixin):
    tz: dt.tzinfo | None
    def strftime(self, date_format) -> Index: ...
    def tz_convert(self, tz) -> Self: ...
    def tz_localize(self, tz, ambiguous: TimeAmbiguous = 'raise', nonexistent: TimeNonexistent = 'raise') -> Self: ...
    def to_period(self, freq: Incomplete | None = None) -> PeriodIndex: ...
    def to_julian_date(self) -> Index: ...
    def isocalendar(self) -> DataFrame: ...
    def __new__(cls, data: Incomplete | None = None, freq: Frequency | lib.NoDefault = ..., tz=..., normalize: bool | lib.NoDefault = ..., closed=..., ambiguous: TimeAmbiguous = 'raise', dayfirst: bool = False, yearfirst: bool = False, dtype: Dtype | None = None, copy: bool = False, name: Hashable | None = None) -> Self: ...
    def __reduce__(self): ...
    def snap(self, freq: Frequency = 'S') -> DatetimeIndex: ...
    def get_loc(self, key): ...
    def slice_indexer(self, start: Incomplete | None = None, end: Incomplete | None = None, step: Incomplete | None = None): ...
    @property
    def inferred_type(self) -> str: ...
    def indexer_at_time(self, time, asof: bool = False) -> npt.NDArray[np.intp]: ...
    def indexer_between_time(self, start_time, end_time, include_start: bool = True, include_end: bool = True) -> npt.NDArray[np.intp]: ...

def date_range(start: Incomplete | None = None, end: Incomplete | None = None, periods: Incomplete | None = None, freq: Incomplete | None = None, tz: Incomplete | None = None, normalize: bool = False, name: Hashable | None = None, inclusive: IntervalClosedType = 'both', *, unit: str | None = None, **kwargs) -> DatetimeIndex: ...
def bdate_range(start: Incomplete | None = None, end: Incomplete | None = None, periods: int | None = None, freq: Frequency | dt.timedelta = 'B', tz: Incomplete | None = None, normalize: bool = True, name: Hashable | None = None, weekmask: Incomplete | None = None, holidays: Incomplete | None = None, inclusive: IntervalClosedType = 'both', **kwargs) -> DatetimeIndex: ...
