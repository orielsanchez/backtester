import numpy as np
from _typeshed import Incomplete
from collections.abc import Hashable, Sequence
from pandas._config import using_copy_on_write as using_copy_on_write, warn_copy_on_write as warn_copy_on_write
from pandas._libs import internals as libinternals, lib as lib
from pandas._libs.internals import BlockPlacement as BlockPlacement, BlockValuesRefs as BlockValuesRefs
from pandas._libs.tslibs import Timestamp as Timestamp
from pandas._typing import ArrayLike as ArrayLike, AxisInt as AxisInt, DtypeObj as DtypeObj, QuantileInterpolation as QuantileInterpolation, Self as Self, Shape as Shape, npt as npt
from pandas.api.extensions import ExtensionArray as ExtensionArray
from pandas.core.arrays import ArrowExtensionArray as ArrowExtensionArray, ArrowStringArray as ArrowStringArray, DatetimeArray as DatetimeArray
from pandas.core.arrays._mixins import NDArrayBackedExtensionArray as NDArrayBackedExtensionArray
from pandas.core.construction import ensure_wrapped_if_datetimelike as ensure_wrapped_if_datetimelike, extract_array as extract_array
from pandas.core.dtypes.cast import infer_dtype_from_scalar as infer_dtype_from_scalar
from pandas.core.dtypes.common import ensure_platform_int as ensure_platform_int, is_1d_only_ea_dtype as is_1d_only_ea_dtype, is_list_like as is_list_like
from pandas.core.dtypes.dtypes import DatetimeTZDtype as DatetimeTZDtype, ExtensionDtype as ExtensionDtype
from pandas.core.dtypes.generic import ABCDataFrame as ABCDataFrame, ABCSeries as ABCSeries
from pandas.core.dtypes.missing import array_equals as array_equals, isna as isna
from pandas.core.indexers import maybe_convert_indices as maybe_convert_indices
from pandas.core.indexes.api import Index as Index, ensure_index as ensure_index
from pandas.core.internals.base import DataManager as DataManager, SingleDataManager as SingleDataManager, ensure_np_dtype as ensure_np_dtype, interleaved_dtype as interleaved_dtype
from pandas.core.internals.blocks import Block as Block, COW_WARNING_GENERAL_MSG as COW_WARNING_GENERAL_MSG, COW_WARNING_SETITEM_MSG as COW_WARNING_SETITEM_MSG, NumpyBlock as NumpyBlock, ensure_block_shape as ensure_block_shape, extend_blocks as extend_blocks, get_block_type as get_block_type, maybe_coerce_values as maybe_coerce_values, new_block as new_block, new_block_2d as new_block_2d
from pandas.core.internals.ops import blockwise_all as blockwise_all, operate_blockwise as operate_blockwise
from pandas.errors import PerformanceWarning as PerformanceWarning
from pandas.util._decorators import cache_readonly as cache_readonly
from pandas.util._exceptions import find_stack_level as find_stack_level
from typing import Callable, Literal

class BaseBlockManager(DataManager):
    blocks: tuple[Block, ...]
    axes: list[Index]
    @property
    def ndim(self) -> int: ...
    def __init__(self, blocks, axes, verify_integrity: bool = True) -> None: ...
    @classmethod
    def from_blocks(cls, blocks: list[Block], axes: list[Index]) -> Self: ...
    @property
    def blknos(self) -> npt.NDArray[np.intp]: ...
    @property
    def blklocs(self) -> npt.NDArray[np.intp]: ...
    def make_empty(self, axes: Incomplete | None = None) -> Self: ...
    def __nonzero__(self) -> bool: ...
    __bool__ = __nonzero__
    def set_axis(self, axis: AxisInt, new_labels: Index) -> None: ...
    @property
    def is_single_block(self) -> bool: ...
    @property
    def items(self) -> Index: ...
    def add_references(self, mgr: BaseBlockManager) -> None: ...
    def references_same_values(self, mgr: BaseBlockManager, blkno: int) -> bool: ...
    def get_dtypes(self) -> npt.NDArray[np.object_]: ...
    @property
    def arrays(self) -> list[ArrayLike]: ...
    def apply(self, f, align_keys: list[str] | None = None, **kwargs) -> Self: ...
    apply_with_block = apply
    def setitem(self, indexer, value, warn: bool = True) -> Self: ...
    def diff(self, n: int) -> Self: ...
    def astype(self, dtype, copy: bool | None = False, errors: str = 'raise') -> Self: ...
    def convert(self, copy: bool | None) -> Self: ...
    def convert_dtypes(self, **kwargs): ...
    def get_values_for_csv(self, *, float_format, date_format, decimal, na_rep: str = 'nan', quoting: Incomplete | None = None) -> Self: ...
    @property
    def any_extension_types(self) -> bool: ...
    @property
    def is_view(self) -> bool: ...
    def get_bool_data(self) -> Self: ...
    def get_numeric_data(self) -> Self: ...
    @property
    def nblocks(self) -> int: ...
    def copy(self, deep: bool | None | Literal['all'] = True) -> Self: ...
    def consolidate(self) -> Self: ...
    def reindex_indexer(self, new_axis: Index, indexer: npt.NDArray[np.intp] | None, axis: AxisInt, fill_value: Incomplete | None = None, allow_dups: bool = False, copy: bool | None = True, only_slice: bool = False, *, use_na_proxy: bool = False) -> Self: ...
    def take(self, indexer: npt.NDArray[np.intp], axis: AxisInt = 1, verify: bool = True) -> Self: ...

class BlockManager(libinternals.BlockManager, BaseBlockManager):
    ndim: int
    def __init__(self, blocks: Sequence[Block], axes: Sequence[Index], verify_integrity: bool = True) -> None: ...
    @classmethod
    def from_blocks(cls, blocks: list[Block], axes: list[Index]) -> Self: ...
    def fast_xs(self, loc: int) -> SingleBlockManager: ...
    def iget(self, i: int, track_ref: bool = True) -> SingleBlockManager: ...
    def iget_values(self, i: int) -> ArrayLike: ...
    @property
    def column_arrays(self) -> list[np.ndarray]: ...
    blocks: Incomplete
    def iset(self, loc: int | slice | np.ndarray, value: ArrayLike, inplace: bool = False, refs: BlockValuesRefs | None = None) -> None: ...
    def column_setitem(self, loc: int, idx: int | slice | np.ndarray, value, inplace_only: bool = False) -> None: ...
    def insert(self, loc: int, item: Hashable, value: ArrayLike, refs: Incomplete | None = None) -> None: ...
    def idelete(self, indexer) -> BlockManager: ...
    def grouped_reduce(self, func: Callable) -> Self: ...
    def reduce(self, func: Callable) -> Self: ...
    def operate_blockwise(self, other: BlockManager, array_op) -> BlockManager: ...
    def quantile(self, *, qs: Index, interpolation: QuantileInterpolation = 'linear') -> Self: ...
    def unstack(self, unstacker, fill_value) -> BlockManager: ...
    def to_dict(self) -> dict[str, Self]: ...
    def as_array(self, dtype: np.dtype | None = None, copy: bool = False, na_value: object = ...) -> np.ndarray: ...
    def is_consolidated(self) -> bool: ...
    @classmethod
    def concat_horizontal(cls, mgrs: list[Self], axes: list[Index]) -> Self: ...
    @classmethod
    def concat_vertical(cls, mgrs: list[Self], axes: list[Index]) -> Self: ...

class SingleBlockManager(BaseBlockManager, SingleDataManager):
    @property
    def ndim(self) -> Literal[1]: ...
    is_single_block: bool
    axes: Incomplete
    blocks: Incomplete
    def __init__(self, block: Block, axis: Index, verify_integrity: bool = False) -> None: ...
    @classmethod
    def from_blocks(cls, blocks: list[Block], axes: list[Index]) -> Self: ...
    @classmethod
    def from_array(cls, array: ArrayLike, index: Index, refs: BlockValuesRefs | None = None) -> SingleBlockManager: ...
    def to_2d_mgr(self, columns: Index) -> BlockManager: ...
    def get_rows_with_mask(self, indexer: npt.NDArray[np.bool_]) -> Self: ...
    def get_slice(self, slobj: slice, axis: AxisInt = 0) -> SingleBlockManager: ...
    @property
    def index(self) -> Index: ...
    @property
    def dtype(self) -> DtypeObj: ...
    def get_dtypes(self) -> npt.NDArray[np.object_]: ...
    def external_values(self): ...
    def internal_values(self): ...
    def array_values(self) -> ExtensionArray: ...
    def get_numeric_data(self) -> Self: ...
    def setitem_inplace(self, indexer, value, warn: bool = True) -> None: ...
    def idelete(self, indexer) -> SingleBlockManager: ...
    def fast_xs(self, loc) -> None: ...
    def set_values(self, values: ArrayLike) -> None: ...

def create_block_manager_from_blocks(blocks: list[Block], axes: list[Index], consolidate: bool = True, verify_integrity: bool = True) -> BlockManager: ...
def create_block_manager_from_column_arrays(arrays: list[ArrayLike], axes: list[Index], consolidate: bool, refs: list) -> BlockManager: ...
def raise_construction_error(tot_items: int, block_shape: Shape, axes: list[Index], e: ValueError | None = None): ...
def make_na_array(dtype: DtypeObj, shape: Shape, fill_value) -> ArrayLike: ...
