import numpy as np
from _typeshed import Incomplete
from collections.abc import Iterable, Sequence
from pandas._config import get_option as get_option, using_copy_on_write as using_copy_on_write, warn_copy_on_write as warn_copy_on_write
from pandas._libs import NaT as NaT, internals as libinternals, lib as lib
from pandas._libs.internals import BlockPlacement as BlockPlacement, BlockValuesRefs as BlockValuesRefs
from pandas._libs.missing import NA as NA
from pandas._typing import ArrayLike as ArrayLike, AxisInt as AxisInt, DtypeBackend as DtypeBackend, DtypeObj as DtypeObj, F as F, FillnaOptions as FillnaOptions, IgnoreRaise as IgnoreRaise, InterpolateOptions as InterpolateOptions, QuantileInterpolation as QuantileInterpolation, Self as Self, Shape as Shape, npt as npt
from pandas.core import missing as missing
from pandas.core.api import Index as Index
from pandas.core.array_algos.putmask import extract_bool_array as extract_bool_array, putmask_inplace as putmask_inplace, putmask_without_repeat as putmask_without_repeat, setitem_datetimelike_compat as setitem_datetimelike_compat, validate_putmask as validate_putmask
from pandas.core.array_algos.quantile import quantile_compat as quantile_compat
from pandas.core.array_algos.replace import compare_or_regex_search as compare_or_regex_search, replace_regex as replace_regex, should_use_regex as should_use_regex
from pandas.core.array_algos.transforms import shift as shift
from pandas.core.arrays import Categorical as Categorical, DatetimeArray as DatetimeArray, ExtensionArray as ExtensionArray, IntervalArray as IntervalArray, NumpyExtensionArray as NumpyExtensionArray, PeriodArray as PeriodArray, TimedeltaArray as TimedeltaArray
from pandas.core.arrays._mixins import NDArrayBackedExtensionArray as NDArrayBackedExtensionArray
from pandas.core.base import PandasObject as PandasObject
from pandas.core.computation import expressions as expressions
from pandas.core.construction import ensure_wrapped_if_datetimelike as ensure_wrapped_if_datetimelike, extract_array as extract_array
from pandas.core.dtypes.astype import astype_array_safe as astype_array_safe, astype_is_view as astype_is_view
from pandas.core.dtypes.cast import LossySetitemError as LossySetitemError, can_hold_element as can_hold_element, convert_dtypes as convert_dtypes, find_result_type as find_result_type, maybe_downcast_to_dtype as maybe_downcast_to_dtype, np_can_hold_element as np_can_hold_element
from pandas.core.dtypes.common import is_1d_only_ea_dtype as is_1d_only_ea_dtype, is_float_dtype as is_float_dtype, is_integer_dtype as is_integer_dtype, is_list_like as is_list_like, is_scalar as is_scalar, is_string_dtype as is_string_dtype
from pandas.core.dtypes.dtypes import DatetimeTZDtype as DatetimeTZDtype, ExtensionDtype as ExtensionDtype, IntervalDtype as IntervalDtype, NumpyEADtype as NumpyEADtype, PeriodDtype as PeriodDtype
from pandas.core.dtypes.generic import ABCDataFrame as ABCDataFrame, ABCIndex as ABCIndex, ABCNumpyExtensionArray as ABCNumpyExtensionArray, ABCSeries as ABCSeries
from pandas.core.dtypes.missing import is_valid_na_for_dtype as is_valid_na_for_dtype, isna as isna, na_value_for_dtype as na_value_for_dtype
from pandas.core.indexers import check_setitem_lengths as check_setitem_lengths
from pandas.core.indexes.base import get_values_for_csv as get_values_for_csv
from pandas.errors import AbstractMethodError as AbstractMethodError
from pandas.util._decorators import cache_readonly as cache_readonly
from pandas.util._exceptions import find_stack_level as find_stack_level
from pandas.util._validators import validate_bool_kwarg as validate_bool_kwarg
from typing import Any, Callable, Literal

COW_WARNING_GENERAL_MSG: str
COW_WARNING_SETITEM_MSG: str

def maybe_split(meth: F) -> F: ...

class Block(PandasObject, libinternals.Block):
    values: np.ndarray | ExtensionArray
    ndim: int
    refs: BlockValuesRefs
    __init__: Callable
    is_numeric: bool
    def is_object(self) -> bool: ...
    def is_extension(self) -> bool: ...
    @property
    def is_bool(self) -> bool: ...
    def external_values(self): ...
    def fill_value(self): ...
    @property
    def mgr_locs(self) -> BlockPlacement: ...
    @mgr_locs.setter
    def mgr_locs(self, new_mgr_locs: BlockPlacement) -> None: ...
    def make_block(self, values, placement: BlockPlacement | None = None, refs: BlockValuesRefs | None = None) -> Block: ...
    def make_block_same_class(self, values, placement: BlockPlacement | None = None, refs: BlockValuesRefs | None = None) -> Self: ...
    def __len__(self) -> int: ...
    def slice_block_columns(self, slc: slice) -> Self: ...
    def take_block_columns(self, indices: npt.NDArray[np.intp]) -> Self: ...
    def getitem_block_columns(self, slicer: slice, new_mgr_locs: BlockPlacement, ref_inplace_op: bool = False) -> Self: ...
    def should_store(self, value: ArrayLike) -> bool: ...
    def apply(self, func, **kwargs) -> list[Block]: ...
    def reduce(self, func) -> list[Block]: ...
    def split_and_operate(self, func, *args, **kwargs) -> list[Block]: ...
    def coerce_to_target_dtype(self, other, warn_on_upcast: bool = False) -> Block: ...
    def convert(self, *, copy: bool = True, using_cow: bool = False) -> list[Block]: ...
    def convert_dtypes(self, copy: bool, using_cow: bool, infer_objects: bool = True, convert_string: bool = True, convert_integer: bool = True, convert_boolean: bool = True, convert_floating: bool = True, dtype_backend: DtypeBackend = 'numpy_nullable') -> list[Block]: ...
    def dtype(self) -> DtypeObj: ...
    def astype(self, dtype: DtypeObj, copy: bool = False, errors: IgnoreRaise = 'raise', using_cow: bool = False, squeeze: bool = False) -> Block: ...
    def get_values_for_csv(self, *, float_format, date_format, decimal, na_rep: str = 'nan', quoting: Incomplete | None = None) -> Block: ...
    def copy(self, deep: bool = True) -> Self: ...
    def replace(self, to_replace, value, inplace: bool = False, mask: npt.NDArray[np.bool_] | None = None, using_cow: bool = False, already_warned: Incomplete | None = None) -> list[Block]: ...
    def replace_list(self, src_list: Iterable[Any], dest_list: Sequence[Any], inplace: bool = False, regex: bool = False, using_cow: bool = False, already_warned: Incomplete | None = None) -> list[Block]: ...
    @property
    def shape(self) -> Shape: ...
    def iget(self, i: int | tuple[int, int] | tuple[slice, int]) -> np.ndarray: ...
    def set_inplace(self, locs, values: ArrayLike, copy: bool = False) -> None: ...
    def take_nd(self, indexer: npt.NDArray[np.intp], axis: AxisInt, new_mgr_locs: BlockPlacement | None = None, fill_value=...) -> Block: ...
    def setitem(self, indexer, value, using_cow: bool = False) -> Block: ...
    def putmask(self, mask, new, using_cow: bool = False, already_warned: Incomplete | None = None) -> list[Block]: ...
    def where(self, other, cond, _downcast: str | bool = 'infer', using_cow: bool = False) -> list[Block]: ...
    def fillna(self, value, limit: int | None = None, inplace: bool = False, downcast: Incomplete | None = None, using_cow: bool = False, already_warned: Incomplete | None = None) -> list[Block]: ...
    def pad_or_backfill(self, *, method: FillnaOptions, axis: AxisInt = 0, inplace: bool = False, limit: int | None = None, limit_area: Literal['inside', 'outside'] | None = None, downcast: Literal['infer'] | None = None, using_cow: bool = False, already_warned: Incomplete | None = None) -> list[Block]: ...
    def interpolate(self, *, method: InterpolateOptions, index: Index, inplace: bool = False, limit: int | None = None, limit_direction: Literal['forward', 'backward', 'both'] = 'forward', limit_area: Literal['inside', 'outside'] | None = None, downcast: Literal['infer'] | None = None, using_cow: bool = False, already_warned: Incomplete | None = None, **kwargs) -> list[Block]: ...
    def diff(self, n: int) -> list[Block]: ...
    def shift(self, periods: int, fill_value: Any = None) -> list[Block]: ...
    def quantile(self, qs: Index, interpolation: QuantileInterpolation = 'linear') -> Block: ...
    def round(self, decimals: int, using_cow: bool = False) -> Self: ...
    def delete(self, loc) -> list[Block]: ...
    @property
    def is_view(self) -> bool: ...
    @property
    def array_values(self) -> ExtensionArray: ...
    def get_values(self, dtype: DtypeObj | None = None) -> np.ndarray: ...

class EABackedBlock(Block):
    values: ExtensionArray
    def shift(self, periods: int, fill_value: Any = None) -> list[Block]: ...
    def setitem(self, indexer, value, using_cow: bool = False): ...
    def where(self, other, cond, _downcast: str | bool = 'infer', using_cow: bool = False) -> list[Block]: ...
    def putmask(self, mask, new, using_cow: bool = False, already_warned: Incomplete | None = None) -> list[Block]: ...
    def delete(self, loc) -> list[Block]: ...
    def array_values(self) -> ExtensionArray: ...
    def get_values(self, dtype: DtypeObj | None = None) -> np.ndarray: ...
    def pad_or_backfill(self, *, method: FillnaOptions, axis: AxisInt = 0, inplace: bool = False, limit: int | None = None, limit_area: Literal['inside', 'outside'] | None = None, downcast: Literal['infer'] | None = None, using_cow: bool = False, already_warned: Incomplete | None = None) -> list[Block]: ...

class ExtensionBlock(EABackedBlock):
    values: ExtensionArray
    def fillna(self, value, limit: int | None = None, inplace: bool = False, downcast: Incomplete | None = None, using_cow: bool = False, already_warned: Incomplete | None = None) -> list[Block]: ...
    def shape(self) -> Shape: ...
    def iget(self, i: int | tuple[int, int] | tuple[slice, int]): ...
    def set_inplace(self, locs, values: ArrayLike, copy: bool = False) -> None: ...
    @property
    def is_view(self) -> bool: ...
    def is_numeric(self) -> bool: ...
    def slice_block_rows(self, slicer: slice) -> Self: ...

class NumpyBlock(Block):
    values: np.ndarray
    @property
    def is_view(self) -> bool: ...
    @property
    def array_values(self) -> ExtensionArray: ...
    def get_values(self, dtype: DtypeObj | None = None) -> np.ndarray: ...
    def is_numeric(self) -> bool: ...

class NumericBlock(NumpyBlock): ...
class ObjectBlock(NumpyBlock): ...

class NDArrayBackedExtensionBlock(EABackedBlock):
    values: NDArrayBackedExtensionArray
    @property
    def is_view(self) -> bool: ...

class DatetimeLikeBlock(NDArrayBackedExtensionBlock):
    is_numeric: bool
    values: DatetimeArray | TimedeltaArray

class DatetimeTZBlock(DatetimeLikeBlock):
    values: DatetimeArray

def maybe_coerce_values(values: ArrayLike) -> ArrayLike: ...
def get_block_type(dtype: DtypeObj) -> type[Block]: ...
def new_block_2d(values: ArrayLike, placement: BlockPlacement, refs: BlockValuesRefs | None = None): ...
def new_block(values, placement: BlockPlacement, *, ndim: int, refs: BlockValuesRefs | None = None) -> Block: ...
def check_ndim(values, placement: BlockPlacement, ndim: int) -> None: ...
def extract_pandas_array(values: ArrayLike, dtype: DtypeObj | None, ndim: int) -> tuple[ArrayLike, DtypeObj | None]: ...
def extend_blocks(result, blocks: Incomplete | None = None) -> list[Block]: ...
def ensure_block_shape(values: ArrayLike, ndim: int = 1) -> ArrayLike: ...
def external_values(values: ArrayLike) -> ArrayLike: ...
