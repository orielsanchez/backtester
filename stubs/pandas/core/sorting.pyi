import numpy as np
from _typeshed import Incomplete
from collections.abc import Hashable, Iterable, Sequence
from pandas import MultiIndex as MultiIndex, Series as Series
from pandas._libs import algos as algos, hashtable as hashtable, lib as lib
from pandas._libs.hashtable import unique_label_indices as unique_label_indices
from pandas._typing import ArrayLike as ArrayLike, AxisInt as AxisInt, IndexKeyFunc as IndexKeyFunc, Level as Level, NaPosition as NaPosition, Shape as Shape, SortKind as SortKind, npt as npt
from pandas.core.arrays import ExtensionArray as ExtensionArray
from pandas.core.construction import extract_array as extract_array
from pandas.core.dtypes.common import ensure_int64 as ensure_int64, ensure_platform_int as ensure_platform_int
from pandas.core.dtypes.generic import ABCMultiIndex as ABCMultiIndex, ABCRangeIndex as ABCRangeIndex
from pandas.core.dtypes.missing import isna as isna
from pandas.core.indexes.base import Index as Index
from typing import Callable

def get_indexer_indexer(target: Index, level: Level | list[Level] | None, ascending: list[bool] | bool, kind: SortKind, na_position: NaPosition, sort_remaining: bool, key: IndexKeyFunc) -> npt.NDArray[np.intp] | None: ...
def get_group_index(labels, shape: Shape, sort: bool, xnull: bool) -> npt.NDArray[np.int64]: ...
def get_compressed_ids(labels, sizes: Shape) -> tuple[npt.NDArray[np.intp], npt.NDArray[np.int64]]: ...
def is_int64_overflow_possible(shape: Shape) -> bool: ...
def decons_obs_group_ids(comp_ids: npt.NDArray[np.intp], obs_ids: npt.NDArray[np.intp], shape: Shape, labels: Sequence[npt.NDArray[np.signedinteger]], xnull: bool) -> list[npt.NDArray[np.intp]]: ...
def lexsort_indexer(keys: Sequence[ArrayLike | Index | Series], orders: Incomplete | None = None, na_position: str = 'last', key: Callable | None = None, codes_given: bool = False) -> npt.NDArray[np.intp]: ...
def nargsort(items: ArrayLike | Index | Series, kind: SortKind = 'quicksort', ascending: bool = True, na_position: str = 'last', key: Callable | None = None, mask: npt.NDArray[np.bool_] | None = None) -> npt.NDArray[np.intp]: ...
def nargminmax(values: ExtensionArray, method: str, axis: AxisInt = 0): ...
def ensure_key_mapped(values: ArrayLike | Index | Series, key: Callable | None, levels: Incomplete | None = None) -> ArrayLike | Index | Series: ...
def get_flattened_list(comp_ids: npt.NDArray[np.intp], ngroups: int, levels: Iterable[Index], labels: Iterable[np.ndarray]) -> list[tuple]: ...
def get_indexer_dict(label_list: list[np.ndarray], keys: list[Index]) -> dict[Hashable, npt.NDArray[np.intp]]: ...
def get_group_index_sorter(group_index: npt.NDArray[np.intp], ngroups: int | None = None) -> npt.NDArray[np.intp]: ...
def compress_group_index(group_index: npt.NDArray[np.int64], sort: bool = True) -> tuple[npt.NDArray[np.int64], npt.NDArray[np.int64]]: ...
