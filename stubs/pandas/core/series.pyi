import numpy as np
from _typeshed import Incomplete
from collections.abc import Hashable, Iterable, Mapping, Sequence
from pandas._libs import lib
from pandas._typing import AggFuncType, AnyAll, AnyArrayLike, ArrayLike, Axis, CorrelationMethod, DropKeep, Dtype, DtypeObj, FilePath, Frequency, IgnoreRaise, IndexKeyFunc, IndexLabel, Level, MutableMappingT, NaPosition, NumpySorter, NumpyValueArrayLike, QuantileInterpolation, ReindexMethod, Renamer, Scalar, Self, SortKind, StorageOptions, Suffixes, ValueKeyFunc, WriteBuffer, npt
from pandas.core import base
from pandas.core.arrays import ExtensionArray
from pandas.core.frame import DataFrame
from pandas.core.generic import NDFrame
from pandas.core.groupby.generic import SeriesGroupBy
from pandas.core.indexes.api import Index
from typing import Any, Callable, IO, Literal, overload

__all__ = ['Series']

class Series(base.IndexOpsMixin, NDFrame):
    __pandas_priority__: int
    hasnans: Incomplete
    def __init__(self, data: Incomplete | None = None, index: Incomplete | None = None, dtype: Dtype | None = None, name: Incomplete | None = None, copy: bool | None = None, fastpath: bool | lib.NoDefault = ...) -> None: ...
    @property
    def dtype(self) -> DtypeObj: ...
    @property
    def dtypes(self) -> DtypeObj: ...
    @property
    def name(self) -> Hashable: ...
    @name.setter
    def name(self, value: Hashable) -> None: ...
    @property
    def values(self): ...
    @property
    def array(self) -> ExtensionArray: ...
    def ravel(self, order: str = 'C') -> ArrayLike: ...
    def __len__(self) -> int: ...
    def view(self, dtype: Dtype | None = None) -> Series: ...
    def __array__(self, dtype: npt.DTypeLike | None = None, copy: bool | None = None) -> np.ndarray: ...
    def __column_consortium_standard__(self, *, api_version: str | None = None) -> Any: ...
    __float__: Incomplete
    __int__: Incomplete
    @property
    def axes(self) -> list[Index]: ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value) -> None: ...
    def repeat(self, repeats: int | Sequence[int], axis: None = None) -> Series: ...
    @overload
    def reset_index(self, level: IndexLabel = ..., *, drop: Literal[False] = ..., name: Level = ..., inplace: Literal[False] = ..., allow_duplicates: bool = ...) -> DataFrame: ...
    @overload
    def reset_index(self, level: IndexLabel = ..., *, drop: Literal[True], name: Level = ..., inplace: Literal[False] = ..., allow_duplicates: bool = ...) -> Series: ...
    @overload
    def reset_index(self, level: IndexLabel = ..., *, drop: bool = ..., name: Level = ..., inplace: Literal[True], allow_duplicates: bool = ...) -> None: ...
    @overload
    def to_string(self, buf: None = ..., na_rep: str = ..., float_format: str | None = ..., header: bool = ..., index: bool = ..., length: bool = ..., dtype=..., name=..., max_rows: int | None = ..., min_rows: int | None = ...) -> str: ...
    @overload
    def to_string(self, buf: FilePath | WriteBuffer[str], na_rep: str = ..., float_format: str | None = ..., header: bool = ..., index: bool = ..., length: bool = ..., dtype=..., name=..., max_rows: int | None = ..., min_rows: int | None = ...) -> None: ...
    def to_markdown(self, buf: IO[str] | None = None, mode: str = 'wt', index: bool = True, storage_options: StorageOptions | None = None, **kwargs) -> str | None: ...
    def items(self) -> Iterable[tuple[Hashable, Any]]: ...
    def keys(self) -> Index: ...
    @overload
    def to_dict(self, *, into: type[MutableMappingT] | MutableMappingT) -> MutableMappingT: ...
    @overload
    def to_dict(self, *, into: type[dict] = ...) -> dict: ...
    def to_frame(self, name: Hashable = ...) -> DataFrame: ...
    def groupby(self, by: Incomplete | None = None, axis: Axis = 0, level: IndexLabel | None = None, as_index: bool = True, sort: bool = True, group_keys: bool = True, observed: bool | lib.NoDefault = ..., dropna: bool = True) -> SeriesGroupBy: ...
    def count(self) -> int: ...
    def mode(self, dropna: bool = True) -> Series: ...
    def unique(self) -> ArrayLike: ...
    @overload
    def drop_duplicates(self, *, keep: DropKeep = ..., inplace: Literal[False] = ..., ignore_index: bool = ...) -> Series: ...
    @overload
    def drop_duplicates(self, *, keep: DropKeep = ..., inplace: Literal[True], ignore_index: bool = ...) -> None: ...
    @overload
    def drop_duplicates(self, *, keep: DropKeep = ..., inplace: bool = ..., ignore_index: bool = ...) -> Series | None: ...
    def duplicated(self, keep: DropKeep = 'first') -> Series: ...
    def idxmin(self, axis: Axis = 0, skipna: bool = True, *args, **kwargs) -> Hashable: ...
    def idxmax(self, axis: Axis = 0, skipna: bool = True, *args, **kwargs) -> Hashable: ...
    def round(self, decimals: int = 0, *args, **kwargs) -> Series: ...
    @overload
    def quantile(self, q: float = ..., interpolation: QuantileInterpolation = ...) -> float: ...
    @overload
    def quantile(self, q: Sequence[float] | AnyArrayLike, interpolation: QuantileInterpolation = ...) -> Series: ...
    @overload
    def quantile(self, q: float | Sequence[float] | AnyArrayLike = ..., interpolation: QuantileInterpolation = ...) -> float | Series: ...
    def corr(self, other: Series, method: CorrelationMethod = 'pearson', min_periods: int | None = None) -> float: ...
    def cov(self, other: Series, min_periods: int | None = None, ddof: int | None = 1) -> float: ...
    def diff(self, periods: int = 1) -> Series: ...
    def autocorr(self, lag: int = 1) -> float: ...
    def dot(self, other: AnyArrayLike) -> Series | np.ndarray: ...
    def __matmul__(self, other): ...
    def __rmatmul__(self, other): ...
    def searchsorted(self, value: NumpyValueArrayLike | ExtensionArray, side: Literal['left', 'right'] = 'left', sorter: NumpySorter | None = None) -> npt.NDArray[np.intp] | np.intp: ...
    def compare(self, other: Series, align_axis: Axis = 1, keep_shape: bool = False, keep_equal: bool = False, result_names: Suffixes = ('self', 'other')) -> DataFrame | Series: ...
    def combine(self, other: Series | Hashable, func: Callable[[Hashable, Hashable], Hashable], fill_value: Hashable | None = None) -> Series: ...
    def combine_first(self, other) -> Series: ...
    def update(self, other: Series | Sequence | Mapping) -> None: ...
    @overload
    def sort_values(self, *, axis: Axis = ..., ascending: bool | Sequence[bool] = ..., inplace: Literal[False] = ..., kind: SortKind = ..., na_position: NaPosition = ..., ignore_index: bool = ..., key: ValueKeyFunc = ...) -> Series: ...
    @overload
    def sort_values(self, *, axis: Axis = ..., ascending: bool | Sequence[bool] = ..., inplace: Literal[True], kind: SortKind = ..., na_position: NaPosition = ..., ignore_index: bool = ..., key: ValueKeyFunc = ...) -> None: ...
    @overload
    def sort_values(self, *, axis: Axis = ..., ascending: bool | Sequence[bool] = ..., inplace: bool = ..., kind: SortKind = ..., na_position: NaPosition = ..., ignore_index: bool = ..., key: ValueKeyFunc = ...) -> Series | None: ...
    @overload
    def sort_index(self, *, axis: Axis = ..., level: IndexLabel = ..., ascending: bool | Sequence[bool] = ..., inplace: Literal[True], kind: SortKind = ..., na_position: NaPosition = ..., sort_remaining: bool = ..., ignore_index: bool = ..., key: IndexKeyFunc = ...) -> None: ...
    @overload
    def sort_index(self, *, axis: Axis = ..., level: IndexLabel = ..., ascending: bool | Sequence[bool] = ..., inplace: Literal[False] = ..., kind: SortKind = ..., na_position: NaPosition = ..., sort_remaining: bool = ..., ignore_index: bool = ..., key: IndexKeyFunc = ...) -> Series: ...
    @overload
    def sort_index(self, *, axis: Axis = ..., level: IndexLabel = ..., ascending: bool | Sequence[bool] = ..., inplace: bool = ..., kind: SortKind = ..., na_position: NaPosition = ..., sort_remaining: bool = ..., ignore_index: bool = ..., key: IndexKeyFunc = ...) -> Series | None: ...
    def argsort(self, axis: Axis = 0, kind: SortKind = 'quicksort', order: None = None, stable: None = None) -> Series: ...
    def nlargest(self, n: int = 5, keep: Literal['first', 'last', 'all'] = 'first') -> Series: ...
    def nsmallest(self, n: int = 5, keep: Literal['first', 'last', 'all'] = 'first') -> Series: ...
    def swaplevel(self, i: Level = -2, j: Level = -1, copy: bool | None = None) -> Series: ...
    def reorder_levels(self, order: Sequence[Level]) -> Series: ...
    def explode(self, ignore_index: bool = False) -> Series: ...
    def unstack(self, level: IndexLabel = -1, fill_value: Hashable | None = None, sort: bool = True) -> DataFrame: ...
    def map(self, arg: Callable | Mapping | Series, na_action: Literal['ignore'] | None = None) -> Series: ...
    def aggregate(self, func: Incomplete | None = None, axis: Axis = 0, *args, **kwargs): ...
    agg = aggregate
    def transform(self, func: AggFuncType, axis: Axis = 0, *args, **kwargs) -> DataFrame | Series: ...
    def apply(self, func: AggFuncType, convert_dtype: bool | lib.NoDefault = ..., args: tuple[Any, ...] = (), *, by_row: Literal[False, 'compat'] = 'compat', **kwargs) -> DataFrame | Series: ...
    @overload
    def rename(self, index: Renamer | Hashable | None = ..., *, axis: Axis | None = ..., copy: bool = ..., inplace: Literal[True], level: Level | None = ..., errors: IgnoreRaise = ...) -> None: ...
    @overload
    def rename(self, index: Renamer | Hashable | None = ..., *, axis: Axis | None = ..., copy: bool = ..., inplace: Literal[False] = ..., level: Level | None = ..., errors: IgnoreRaise = ...) -> Series: ...
    @overload
    def rename(self, index: Renamer | Hashable | None = ..., *, axis: Axis | None = ..., copy: bool = ..., inplace: bool = ..., level: Level | None = ..., errors: IgnoreRaise = ...) -> Series | None: ...
    def set_axis(self, labels, *, axis: Axis = 0, copy: bool | None = None) -> Series: ...
    def reindex(self, index: Incomplete | None = None, *, axis: Axis | None = None, method: ReindexMethod | None = None, copy: bool | None = None, level: Level | None = None, fill_value: Scalar | None = None, limit: int | None = None, tolerance: Incomplete | None = None) -> Series: ...
    @overload
    def rename_axis(self, mapper: IndexLabel | lib.NoDefault = ..., *, index=..., axis: Axis = ..., copy: bool = ..., inplace: Literal[True]) -> None: ...
    @overload
    def rename_axis(self, mapper: IndexLabel | lib.NoDefault = ..., *, index=..., axis: Axis = ..., copy: bool = ..., inplace: Literal[False] = ...) -> Self: ...
    @overload
    def rename_axis(self, mapper: IndexLabel | lib.NoDefault = ..., *, index=..., axis: Axis = ..., copy: bool = ..., inplace: bool = ...) -> Self | None: ...
    @overload
    def drop(self, labels: IndexLabel = ..., *, axis: Axis = ..., index: IndexLabel = ..., columns: IndexLabel = ..., level: Level | None = ..., inplace: Literal[True], errors: IgnoreRaise = ...) -> None: ...
    @overload
    def drop(self, labels: IndexLabel = ..., *, axis: Axis = ..., index: IndexLabel = ..., columns: IndexLabel = ..., level: Level | None = ..., inplace: Literal[False] = ..., errors: IgnoreRaise = ...) -> Series: ...
    @overload
    def drop(self, labels: IndexLabel = ..., *, axis: Axis = ..., index: IndexLabel = ..., columns: IndexLabel = ..., level: Level | None = ..., inplace: bool = ..., errors: IgnoreRaise = ...) -> Series | None: ...
    def pop(self, item: Hashable) -> Any: ...
    def info(self, verbose: bool | None = None, buf: IO[str] | None = None, max_cols: int | None = None, memory_usage: bool | str | None = None, show_counts: bool = True) -> None: ...
    def memory_usage(self, index: bool = True, deep: bool = False) -> int: ...
    def isin(self, values) -> Series: ...
    def between(self, left, right, inclusive: Literal['both', 'neither', 'left', 'right'] = 'both') -> Series: ...
    def case_when(self, caselist: list[tuple[ArrayLike | Callable[[Series], Series | np.ndarray | Sequence[bool]], ArrayLike | Scalar | Callable[[Series], Series | np.ndarray]]]) -> Series: ...
    def isna(self) -> Series: ...
    def isnull(self) -> Series: ...
    def notna(self) -> Series: ...
    def notnull(self) -> Series: ...
    @overload
    def dropna(self, *, axis: Axis = ..., inplace: Literal[False] = ..., how: AnyAll | None = ..., ignore_index: bool = ...) -> Series: ...
    @overload
    def dropna(self, *, axis: Axis = ..., inplace: Literal[True], how: AnyAll | None = ..., ignore_index: bool = ...) -> None: ...
    def to_timestamp(self, freq: Frequency | None = None, how: Literal['s', 'e', 'start', 'end'] = 'start', copy: bool | None = None) -> Series: ...
    def to_period(self, freq: str | None = None, copy: bool | None = None) -> Series: ...
    index: Incomplete
    str: Incomplete
    dt: Incomplete
    cat: Incomplete
    plot: Incomplete
    sparse: Incomplete
    struct: Incomplete
    list: Incomplete
    hist: Incomplete
    def eq(self, other, level: Level | None = None, fill_value: float | None = None, axis: Axis = 0) -> Series: ...
    def ne(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def le(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def lt(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def ge(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def gt(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def add(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def radd(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def sub(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    subtract = sub
    def rsub(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def mul(self, other, level: Level | None = None, fill_value: float | None = None, axis: Axis = 0) -> Series: ...
    multiply = mul
    def rmul(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def truediv(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    div = truediv
    divide = truediv
    def rtruediv(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    rdiv = rtruediv
    def floordiv(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def rfloordiv(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def mod(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def rmod(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def pow(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def rpow(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def divmod(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def rdivmod(self, other, level: Incomplete | None = None, fill_value: Incomplete | None = None, axis: Axis = 0) -> Series: ...
    def any(self, *, axis: Axis = 0, bool_only: bool = False, skipna: bool = True, **kwargs) -> bool: ...
    def all(self, axis: Axis = 0, bool_only: bool = False, skipna: bool = True, **kwargs) -> bool: ...
    def min(self, axis: Axis | None = 0, skipna: bool = True, numeric_only: bool = False, **kwargs): ...
    def max(self, axis: Axis | None = 0, skipna: bool = True, numeric_only: bool = False, **kwargs): ...
    def sum(self, axis: Axis | None = None, skipna: bool = True, numeric_only: bool = False, min_count: int = 0, **kwargs): ...
    def prod(self, axis: Axis | None = None, skipna: bool = True, numeric_only: bool = False, min_count: int = 0, **kwargs): ...
    def mean(self, axis: Axis | None = 0, skipna: bool = True, numeric_only: bool = False, **kwargs): ...
    def median(self, axis: Axis | None = 0, skipna: bool = True, numeric_only: bool = False, **kwargs): ...
    def sem(self, axis: Axis | None = None, skipna: bool = True, ddof: int = 1, numeric_only: bool = False, **kwargs): ...
    def var(self, axis: Axis | None = None, skipna: bool = True, ddof: int = 1, numeric_only: bool = False, **kwargs): ...
    def std(self, axis: Axis | None = None, skipna: bool = True, ddof: int = 1, numeric_only: bool = False, **kwargs): ...
    def skew(self, axis: Axis | None = 0, skipna: bool = True, numeric_only: bool = False, **kwargs): ...
    def kurt(self, axis: Axis | None = 0, skipna: bool = True, numeric_only: bool = False, **kwargs): ...
    kurtosis = kurt
    product = prod
    def cummin(self, axis: Axis | None = None, skipna: bool = True, *args, **kwargs): ...
    def cummax(self, axis: Axis | None = None, skipna: bool = True, *args, **kwargs): ...
    def cumsum(self, axis: Axis | None = None, skipna: bool = True, *args, **kwargs): ...
    def cumprod(self, axis: Axis | None = None, skipna: bool = True, *args, **kwargs): ...
