import numpy as np
from _typeshed import Incomplete
from pandas._config import get_option as get_option
from pandas._libs import NaT as NaT, NaTType as NaTType, iNaT as iNaT, lib as lib
from pandas._typing import ArrayLike as ArrayLike, AxisInt as AxisInt, CorrelationMethod as CorrelationMethod, Dtype as Dtype, DtypeObj as DtypeObj, F as F, Scalar as Scalar, Shape as Shape, npt as npt
from pandas.compat._optional import import_optional_dependency as import_optional_dependency
from pandas.core.dtypes.common import is_complex as is_complex, is_float as is_float, is_float_dtype as is_float_dtype, is_integer as is_integer, is_numeric_dtype as is_numeric_dtype, is_object_dtype as is_object_dtype, needs_i8_conversion as needs_i8_conversion, pandas_dtype as pandas_dtype
from pandas.core.dtypes.missing import isna as isna, na_value_for_dtype as na_value_for_dtype, notna as notna
from pandas.util._exceptions import find_stack_level as find_stack_level
from typing import Callable

bn: Incomplete

def set_use_bottleneck(v: bool = True) -> None: ...

class disallow:
    dtypes: Incomplete
    def __init__(self, *dtypes: Dtype) -> None: ...
    def check(self, obj) -> bool: ...
    def __call__(self, f: F) -> F: ...

class bottleneck_switch:
    name: Incomplete
    kwargs: Incomplete
    def __init__(self, name: Incomplete | None = None, **kwargs) -> None: ...
    def __call__(self, alt: F) -> F: ...

def maybe_operate_rowwise(func: F) -> F: ...
def nanany(values: np.ndarray, *, axis: AxisInt | None = None, skipna: bool = True, mask: npt.NDArray[np.bool_] | None = None) -> bool: ...
def nanall(values: np.ndarray, *, axis: AxisInt | None = None, skipna: bool = True, mask: npt.NDArray[np.bool_] | None = None) -> bool: ...
def nansum(values: np.ndarray, *, axis: AxisInt | None = None, skipna: bool = True, min_count: int = 0, mask: npt.NDArray[np.bool_] | None = None) -> float: ...
def nanmean(values: np.ndarray, *, axis: AxisInt | None = None, skipna: bool = True, mask: npt.NDArray[np.bool_] | None = None) -> float: ...
def nanmedian(values, *, axis: AxisInt | None = None, skipna: bool = True, mask: Incomplete | None = None): ...
def nanstd(values, *, axis: AxisInt | None = None, skipna: bool = True, ddof: int = 1, mask: Incomplete | None = None): ...
def nanvar(values: np.ndarray, *, axis: AxisInt | None = None, skipna: bool = True, ddof: int = 1, mask: Incomplete | None = None): ...
def nansem(values: np.ndarray, *, axis: AxisInt | None = None, skipna: bool = True, ddof: int = 1, mask: npt.NDArray[np.bool_] | None = None) -> float: ...

nanmin: Incomplete
nanmax: Incomplete

def nanargmax(values: np.ndarray, *, axis: AxisInt | None = None, skipna: bool = True, mask: npt.NDArray[np.bool_] | None = None) -> int | np.ndarray: ...
def nanargmin(values: np.ndarray, *, axis: AxisInt | None = None, skipna: bool = True, mask: npt.NDArray[np.bool_] | None = None) -> int | np.ndarray: ...
def nanskew(values: np.ndarray, *, axis: AxisInt | None = None, skipna: bool = True, mask: npt.NDArray[np.bool_] | None = None) -> float: ...
def nankurt(values: np.ndarray, *, axis: AxisInt | None = None, skipna: bool = True, mask: npt.NDArray[np.bool_] | None = None) -> float: ...
def nanprod(values: np.ndarray, *, axis: AxisInt | None = None, skipna: bool = True, min_count: int = 0, mask: npt.NDArray[np.bool_] | None = None) -> float: ...
def check_below_min_count(shape: tuple[int, ...], mask: npt.NDArray[np.bool_] | None, min_count: int) -> bool: ...
def nancorr(a: np.ndarray, b: np.ndarray, *, method: CorrelationMethod = 'pearson', min_periods: int | None = None) -> float: ...
def get_corr_func(method: CorrelationMethod) -> Callable[[np.ndarray, np.ndarray], float]: ...
def nancov(a: np.ndarray, b: np.ndarray, *, min_periods: int | None = None, ddof: int | None = 1) -> float: ...
def na_accum_func(values: ArrayLike, accum_func, *, skipna: bool) -> ArrayLike: ...
